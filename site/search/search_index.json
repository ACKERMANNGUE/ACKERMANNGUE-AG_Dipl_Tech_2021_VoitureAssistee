{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"documentation_technique/","text":"Documentation technique de Voiture Assist\u00e9e R\u00e9sum\u00e9 Voiture assist\u00e9e est un projet d'\u00e9tude portant sur les voitures autonomes et leurs fonctionnement. Ce projet me f\u00fbt propos\u00e9 par M. Bonvin \u00e9tant donn\u00e9 que la premi\u00e8re \u00e9bauche du cahier des charges comportait en une simulation de voiture autonome mais ce dans une application windows form. M. Bonvin ayant entendu parler de mon projet, il a s\u00fb amener un c\u00f4t\u00e9 plus int\u00e9ressant et professionnel dans le travail que je vais devoir r\u00e9aliser. \u00c9tant donn\u00e9 la d\u00e9couverte des diff\u00e9rents appareils utilis\u00e9 pour ce projet, la plus value sera surtout l'acquisition de nouvelles connaissances dans le domaine de l'informatique physique. Par cons\u00e9quent, le but du projet est de r\u00e9aliser une voiture se d\u00e9pla\u00e7able \u00e0 l'aide une interface web et qui sait se d\u00e9placer par elle m\u00eame en \u00e9vitant les obstacles sur sa route. Abstract Voiture assist\u00e9e is a study project about autonomous cars and their functioning. This project was proposed to me by Mr. Bonvin since the first draft of the specifications included a simulation of an autonomous car but in a windows form application. Mr. Bonvin heard about my project, he knew how to bring a more interesting and professional side in the work that I will have to realize. Considering the discovery of the different devices used for this project, the added value will be especially the acquisition of new knowledge in the field of physical computing. Therefore, the goal of the project is to realize a car that can be moved by a web interface and that knows how to move by itself and which avoids obstacles on its way. Poster Cahier des charges Titre du projet Le titre du projet est Voiture assist\u00e9e car le but du projet est d'en r\u00e9aliser une. Contexte Ce projet m'a \u00e9t\u00e9 propos\u00e9 par M. Bonvin car il a vu que j'allais faire une simulation de voiture autonome, il s'est dit que l'on pourrait tourner la chose autrement. Il a une multitude de Raspberry Pi, de composants ainsi qu'une voiture LEGO controlable. C'est pourquoi il m'a dirig\u00e9 vers une programmation utilisant des capteurs et du bluetooth. Objectif L'objectif principale de ce projet est de r\u00e9aliser une voiture capable de se d\u00e9placer d'un point A \u00e0 un point B en \u00e9vitant les diff\u00e9rents obstacles sur sa route. Pour ce faire, il faudra trouver un moyen de communiquer avec le Technic Hub afin de mouvoir la voiture. Ensuite, il faudra faire fonctionner ind\u00e9pendamment les diff\u00e9rents capteurs. Pour ensuite cr\u00e9er un algorithme \u00e9v\u00e9nementiel g\u00e9rant les diff\u00e9rentes pond\u00e9rations des messages que les capteurs enverront. Technologies et mat\u00e9riels utilis\u00e9s Logiciels Visual Studio Code Python Flask Github Markdown QCAD Photoshop CS6 Pencil Mat\u00e9riels Raspberry Pi 0 WiFi Raspberry Pi 4B 2 Cam\u00e9ra infrarouges (PI NoIR) 4 phares (Bright Pi v1.0) GPS (Ultimate GPS Breakout v3) \u00c9metteur WiFi (ASUS RT-AC58U) LEGO 4x4 X-trem Off-Roader D\u00e9tecteur infrarouge (Flying-Fish) Radar 360 (RPLiDAR A2M8) Environnement de d\u00e9veloppement Pour me connecter au Raspberry Pi sur lequel je travail, j'utilise : Remote SSH pour \u00e9diter le code Il s'agit d'une extension Visual Studio Code disponible ici Github pour publi\u00e9 mon code \u00e9crit sur le Raspberry Pi et pour mettre \u00e0 disposition la documentation technique ainsi que le journal de bord RealVNC pour me connecter \u00e0 distance \u00e0 l'interface graphique du Raspberry Pi Il s'agit d'un logiciel cr\u00e9ant un serveur et un client permettant de contr\u00f4ler \u00e0 distance l'\u00e9cran d'un autre ordinateur, disponible ici . Description d\u00e9taill\u00e9e de ce que l'application fait La voiture est t\u00e9l\u00e9commandable \u00e0 distance \u00e0 l'aide d'une interface web. Sur le site internet, on a acc\u00e8s \u00e0 l'\u00e9tat des diff\u00e9rents capteurs ainsi que les donn\u00e9es qu'ils envoient. Plans de la voiture Dans le croquis du plan de la voiture pr\u00e9sent ci-dessus, je vais \u00e9nonc\u00e9 le r\u00f4le de chaque composant. Les phares sont repr\u00e9sent\u00e9 par le Bright Pi Les d\u00e9tecteurs de sol plac\u00e9s au niveau des roues sont repr\u00e9sent\u00e9 par le Flying-Fish Le Raspberry Pi 4 est repr\u00e9sent\u00e9 par RSP 4 Le Raspberry Pi 0 WiFi est repr\u00e9sent\u00e9 par RSP 0 W Le scanner 360\u00b0 est repr\u00e9sent\u00e9 par le Lidar En comparaison, voici de quoi est \u00e9quip\u00e9e une vraie voiture autonome : Sch\u00e9ma explicatif de l'application L'application offre plusieurs pages. Interface utilisateur de l'application Une page d'interface utilisateur, pour avoir acc\u00e8s aux informations des capteurs ainsi que leurs \u00e9tats. Interface t\u00e9l\u00e9commande Une page de t\u00e9l\u00e9commande pour la voiture. En mode manuel L'utilisateur d\u00e9place la voiture \u00e0 l'aide de la manette disponible sur le site web. En mode automatique La voiture se d\u00e9place de mani\u00e8re rectiligne en \u00e9vitant les obstacles sur sa route. Contact Status Nom Pr\u00e9nom Email Num\u00e9ro de t\u00e9l\u00e9phone \u00c9l\u00e8ve Ackermann Gawen gawen.ackrm@eduge.ch +41 79 88 98 69 4 Professeur de dipl\u00f4me Bonvin Pascal edu-bonvinp@eduge.ch +33 6 32 17 84 11 Structure du projet \u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 Bluetooth \u2502 \u251c\u2500\u2500 Bright Pi \u2502 \u251c\u2500\u2500 Camera \u2502 \u251c\u2500\u2500 Flask \u2502 \u251c\u2500\u2500 Lidar \u2502 \u2514\u2500\u2500 OpenCV \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 plans \u2502 \u251c\u2500\u2500 documentation_technique.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 logbook.md \u2502 \u2514\u2500\u2500 requirements.txt \u251c\u2500\u2500 site \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 documentation_technique \u2502 \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 logbook \u2502 \u251c\u2500\u2500 plans \u2502 \u251c\u2500\u2500 search \u2502 \u251c\u2500\u2500 404.html \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 sitemap.xml \u2502 \u2514\u2500\u2500 sitemap.xml.gz \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 README.md D\u00e9veloppement Description d\u00e9taill\u00e9e de chaques capteurs Raspberry Pi Il s'agit d'un mini ordinateur de la taille d'une carte de cr\u00e9dit \u00e9quip\u00e9s de diff\u00e9rents capteurs, cela d\u00e9pends du mod\u00e8le. Mise en place En fonction du mod\u00e8le du Raspberry Pi il faut flasher les cartes SD avec diff\u00e9rents OS avec le Raspberry Pi Imager : Pour un Raspberry Pi 4, install\u00e9 la version Raspberry Pi OS Full (32-bit) pour faire les tests \u00e0 l'aide d'une interface graphique Pour un Raspberry 0 WiFi, install\u00e9 la version Raspberry Pi OS Lite (32-bit) utilis\u00e9 juste pour transiter des donn\u00e9es Utilisation Un Raspberry Pi 4B est constitu\u00e9 des diff\u00e9rents \u00e9l\u00e9ments : Pour le GPIO, voici les pins disponibles : \u00c0 noter, la pin num\u00e9ro 1 se situe \u00e0 c\u00f4t\u00e9 du module Bluetooth tandis que la pin 39 se situe en diagonal du PoE HAT Header . Cam\u00e9ra La cam\u00e9ra est un module permettant d'avoir acc\u00e8s \u00e0 un flux vid\u00e9o. Mise en place J\u2019ai utilis\u00e9 le guide de la cam\u00e9ra disponible sur https://magpi.raspberrypi.org/books. Pour commencer, j\u2019ai activ\u00e9 la cam\u00e9ra dans le panneau de configuration du Raspberry Pi, puis j\u2019ai branch\u00e9 la cam\u00e9ra dans l\u2019emplacement pr\u00e9vu qui se situe entre la prise jack et les ports HDMI. Le ruban de la cam\u00e9ra doit \u00eatre plac\u00e9 de sorte \u00e0 ce que la languette bleue fasse face \u00e0 la prise jack. Pour m\u2019assurer que la cam\u00e9ra soit fonctionnelle, j\u2019utilise la commande suivante pour prendre une photo raspistill -o test.jpg Utilisation Pour v\u00e9rifier qu'un flux vid\u00e9o pouvait \u00eatre lu, j'ai utilis\u00e9 le code ci dessous : from picamera import PiCamera from time import sleep camera = PiCamera() camera.start_preview() sleep(5) camera.stop_preview() \u00c0 noter, il est n\u00e9cessaire d'ex\u00e9cuter ce code depuis le Raspberry Pi et non par VNC, car l'affichage de la pr\u00e9visualisation du flux ne s'affiche pas. D'apr\u00e8s ce post disponible sur StackEchange, il semblerait que l'aper\u00e7u de la cam\u00e9ra soit g\u00e9r\u00e9 \u00e0 un bas niveau dans le processeur graphique et par cons\u00e9quent n'est visible que par le moniteur directement branch\u00e9 au Raspberry Pi. Phare (Bright Pi v1.0) Le Bright Pi est un module comportant 4 leds infrarouges situ\u00e9es aux extr\u00e9mit\u00e9es et au centre 8 leds. Mise en place Pour l\u2019utilisation du Bright Pi, je me suis bas\u00e9 sur le guide disponible \u00e0 l\u2019adresse suivante : https://learn.pi-supply.com/make/bright-pi-quickstart-faq/. J\u2019ai commenc\u00e9 par activer l\u2019I2C dans le panneau de configuration du Raspberry Pi puis j\u2019ai branch\u00e9 les pins aux emplacements indiqu\u00e9s dans le guide de d\u00e9marrage. Les couleurs ci-dessous doivent \u00eatre respect\u00e9es (pour le placement uniquement). Pour s'assurer que le branchement soit correct, il est n\u00e9cessaire d'utiliser la commande i2cdetect -y 1 . Ceci devrait \u00eatre affich\u00e9 dans la console : Pour tester le Bright Pi, il est n\u00e9cessaire d'avoir le kit de d\u00e9veloppement disponible sur ce repos Github . Utilisation Une fois cela fait, il faut importer les \u00e9l\u00e9ments concernant le brightpi avec from brightpi import * import time Pour faire clignoter les leds manuellement (\u00e0 l\u2019aide de lignes de code) j\u2019aurai pu utiliser l\u2019objet BrightPi, mais j\u2019ai finalement utilis\u00e9 le BrightPiSpecialEffects, car il permet d\u2019avoir acc\u00e8s \u00e0 des fonctions pr\u00e9d\u00e9finies concernant la manipulation des leds, par exemple \u00e0 les faire s\u2019allumer une \u00e0 une dans le sens des aiguilles d\u2019une montre, ce qui peut devenir utile par la suite du travail. Voici le code que j'ai \u00e9crit. Ce code permet de faire clignoter les leds d'un c\u00f4t\u00e9 sp\u00e9cifi\u00e9. def blink(repetitions, speed, right_leds, left_leds, side): # fait clignoter les leds des c\u00f4t\u00e9s sp\u00e9cifi\u00e9s duration = speed / 2 leds_to_activate = [] leds_to_desactivate = [] for i in range(0, repetitions): if side == \"L\": leds_to_activate = left_leds leds_to_desactivate = right_leds if side == \"R\": leds_to_activate = right_leds leds_to_desactivate = left_leds bright_special.set_led_on_off(leds_to_desactivate, OFF) bright_special.set_led_on_off(leds_to_activate, ON) time.sleep(duration) bright_special.set_led_on_off(leds_to_activate, OFF) time.sleep(duration) bright_special = BrightPiSpecialEffects() bright_special.reset() RIGHT_LEDS = [1, 2] LEFT_LEDS = [3, 4] blink(10, 1, RIGHT_LEDS, LEFT_LEDS, \"R\") GPS (Ultimate GPS Breakout v3) Mise en place Utilisation D\u00e9tecteur infrarouge (Flying-Fish) Le Flying-Fish est un module comportant 2 leds infrarouges, une qui \u00e9met et une autre qui re\u00e7ois. Il est \u00e9quip\u00e9 d'un potentiom\u00e8tre r\u00e9glant la distance d'\u00e9mission. Mise en place Comme le montre ce sch\u00e9ma, le Flying-Fish doit \u00eatre connect\u00e9 \u00e0 une alimentation ainsi qu'\u00e0 un Ground (appel\u00e9 Terre en fran\u00e7ais). La derni\u00e8re broche est la sortie. C'est-\u00e0-dire que lorsque la distance d'\u00e9mission regl\u00e9e \u00e0 l'aide du potentiom\u00e8tre est d\u00e9pass\u00e9e, la lumi\u00e8re d'obstacle s'\u00e9teindra et cette broche enverra un signal \u00e9lectrique informant du changement d'\u00e9tat. Utilisation C'est pourquoi, j'ai branch\u00e9 le Vcc sur la pin 1 du GPIO, car le voltage accept\u00e9 est compris entre 3 et 6 Volts, ensuite j'ai branch\u00e9 le Gnd sur la pin 6. Je n'ai pas encore branch\u00e9 le Out \u00e9tant donn\u00e9 que je ne sais pas encore ou je dois le brancher exactement afin de r\u00e9cup\u00e9rer le signal dans le Raspberry. Connexion bluetooth avec le LEGO 4x4 X-trem Off-Roader Le LEGO 4x4 X-trem Off-Roader est une voiture t\u00e9l\u00e9commandable en bluetooth. Mise en place Dans un premier temps, il faut installer bleak , pygatt et bluepy pour ce faire, j'ai utilis\u00e9 cette commande : sudo pip3 install pygatt && pip3 install gatt && pip3 install gattlib && pip3 install bluepy && pip3 install bleak puis j'ai t\u00e9l\u00e9charger le code sources du repository pylgbst . Pour tester la connexion bluetooth, j'ai lanc\u00e9 la commande sudo bluetoothctl , ensuite j'ai lanc\u00e9 les commandes suivantes : power on pour m'assurer que le service soit actif, puis scan on . Une fois que des appareils on \u00e9t\u00e9 d\u00e9tect\u00e9s, on peut lancer l'interface graphique situ\u00e9e dans la barre des t\u00e2ches : ou il est possible d'aller dans les pr\u00e9f\u00e9rences pour l'ouvrir : . Une fois cette interface ouverte, il faut cliquer sur le bouton Rechercher , ce qui effectura un scan des alentours. Une fois le Technic Hub trouv\u00e9 dans la liste, il est n\u00e9cessaire de noter son adresse mac : 90:84:2B:50:36:43 afin de pouvoir l'utiliser par la suite. Utilisation Pour g\u00e9rer le d\u00e9placement de la voiture, \u00e0 l'aide du kit de d\u00e9veloppement fourit par pylgbst, voici le code que j'ai \u00e9crit : from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor, EncodedMotor from pylgbst import * from time import sleep MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" def forward(motor_1, motor_2, motor_3): motor_1.start_power(-1) motor_2.start_power(-1) motor_3.angled(0) print(\"done!\") def downward(motor_1, motor_2, motor_3): motor_1.start_power(1) motor_2.start_power(1) motor_3.angled(0) print(\"done!\") def go_left(motor_3): motor_3.angled(-180) print(\"done!\") def go_right(motor_3): motor_3.angled(180) print(\"done!\") def stop_moving(motor_1, motor_2): motor_1.start_power(0) motor_2.start_power(0) print(\"done!\") def reset_angle(motor_3): motor_3.angled(degrees=-150) print(\"test 1\") sleep(1) motor_3.angled(degrees=-75) print(\"test 2\") sleep(1) def play_scenario(movehub): motor_a = Motor(movehub, movehub.PORT_A) motor_b = Motor(movehub, movehub.PORT_B) motor_c = EncodedMotor(movehub, movehub.PORT_C) print(\"Reset angle:\") reset_angle(motor_c) sleep(2) print(\"Forward:\") forward(motor_a, motor_b, motor_c) sleep(1) print(\"Downward:\") downward(motor_a, motor_b, motor_c) sleep(1) print(\"Stop\") stop_moving(motor_a, motor_b) print(\"Left:\") go_left(motor_c) sleep(2) print(\"Right:\") go_right(motor_c) sleep(2) def exiting(connection): print(\"bye\") connection.disconnect() conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) play_scenario(movehub) exiting(conn) finally: exiting(conn) Le code fournit, propose diff\u00e9rentes m\u00e9thodes de connexion tel que : bluepy bluegiga gatt bleak gattool gattlib Ayant vu dans plusieurs documentations le nom de GATT ressortir, je m'y suis pench\u00e9 pour comprendre de quoi il s'agissait. GATT est un acronyme de l'anglais Generic Attribute Profile , il d\u00e9finit comment les 2 appareils vont \u00e9changer leurs donn\u00e9es, tout en suivant un syst\u00e8me de Services et de Characteristics . C'est pourquoi j'ai utilis\u00e9 la connexion avec GATT . Probl\u00e8me rencontr\u00e9 Au d\u00e9part, je tentais d'appareiller le Raspberry Pi au Technic Hub depuis les commandes disponibles dans dans le mode bluetoothctl , mais j'avais cette erreur Failed to pair: org.bluez.Error.AuthenticationFailed . J'ai alors compris que pour me connecter au Technic hub, j'aurai besoin d'y avoir acc\u00e8s par un moyen qui permette de transmettre des donn\u00e9es car depuis la documentation LEGO, j'ai aper\u00e7u des commandes \u00e9crites avec des bytes en hexad\u00e9cimal. De plus,j'ai remarqu\u00e9 qu'ils mettaient \u00e0 disposition les UUID des hubs car ils ont tous le m\u00eame fabricant. Il y a plein de piste que j'ai entrevues sur les diff\u00e9rents repository, cependant je ne m'y \u00e9tais pas int\u00e9ress\u00e9 plus que \u00e7a, car aucun ne mentionnait le nom de Technic Hub. Apr\u00e8s avoir \u00e9t\u00e9 dans les diff\u00e9rents repository ci-dessous et apr\u00e8s avoir regard\u00e9 comment \u00e9taient \u00e9crit leurs transmission au hub bluetooth. J'ai r\u00e9ussi \u00e0 comprendre comment je pouvais m'appareiller au Technic Hub et comment int\u00e9ragir avec. Radar 360 (RPLiDAR A2M8) Le RPLiDAR A2M8 est un scanner laser \u00e0 360\u00b0. Il permet de conna\u00eetre la distance entre lui et les obstacles \u00e0 chaque angles. Mise en place Le lidar est branchable par port s\u00e9rie. Cependant, un adaptateur est founie avec et nous permet de r\u00e9cup\u00e9rer les donn\u00e9es par USB. Au dos de l'adaptateur, on peut y voir les \u00e9l\u00e9ments suivants : Couleur du c\u00e2ble Nom du signal Type de signal Description Tension minimale Tension habituelle Tension maximale Rouge VCC Power Puissance totale 4.9V 5V 5.2V Vert TX Output Sortie des donn\u00e9es sur le port s\u00e9rie relative au scanner 0V 3.3V 3.5V Jaune RX Input Entr\u00e9e des donn\u00e9es sur le port s\u00e9rie relative au scanner 0V 3.3V 3.5V Noir GND Power La Terre 0V 0V 0V Bleu MOTOCTL Input Moteur de scan, r\u00e9gul\u00e9 avec un PWM 0V 3.3V 5V Informations compl\u00e9mentaires pour le PWM, voici les valeurs utilis\u00e9es : Unit\u00e9 Valeur minimale Valeur habituelle Valeur maximale Haut niveau de tension Volts 3.0 3.3 5 Fr\u00e9quence du PWM Herz 24,500 25,000 25,500 Plage de cycles d'utilisation Pourcent 0 60 100 Si on le souhaite, on peut modifier la vitesse de transmission. De base, la vitesse de transmission est param\u00e9tr\u00e9e sur 115'200 Baud mais on peut la mont\u00e9e \u00e0 256'000 Baud. Il faut commencer par t\u00e9l\u00e9charger le kit de d\u00e9veloppement disponible sur le repository officiel de Slamtec . Une fois le SDK t\u00e9l\u00e9charg\u00e9 sur le Raspberry. Nous pouvons brancher le Lidar \u00e0 l'adaptateur. Depuis l'adaptateur, branch\u00e9 le micro-USB dessus puis l'USB au Raspberry Pi. Utilisation Afin de v\u00e9rifier qu'il soit bien d\u00e9tecter, il faut ex\u00e9cuter la commande suivante ls /dev/*USB* ceci devrait \u00eatre retourn\u00e9 /dev/ttyUSB0 . Dans le dossier du code source, il faut aller dans le r\u00e9pertoire sdk/app/ et ex\u00e9cuter la commande make dans un terminal. Pour ex\u00e9cuter l'un des 3 programmes suivant : ultra_simple simple_grabber frame_grabber Nous pouvons maintenant ex\u00e9cuter le programme souhait\u00e9 en utilisant la commande suivante dans un terminal : nom_du_programme /dev/ttyUSB0 . Probl\u00e8me rencontr\u00e9 Les codes fournis fonctionnent parfaitement, sauf que aucun ne permet de r\u00e9cup\u00e9rer depuis une variable ou autre les valeurs d'angles. Cependant, elles sont affich\u00e9es dans la console. \u00c9metteur WiFi (ASUS RT-AC58U) Mise en place Utilisation Python Flask Flask est un framework web disponible en python qui permet de d\u00e9velopper ais\u00e9ment des applications web. Mise en place Flask est t\u00e9l\u00e9chargeable depuis la commande pip3 install Flask . Utilisation Dans un premier temps, il est important de cr\u00e9er une fichier python. Dans cet exemple, ce sera hello.py . Application de base Il faut d'abord importer Flask. Et l'initialiser de la mani\u00e8re suivante : from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' Pour lancer l'application, il faut d'abord exporter la variable d'environnment FLASK_APP de la mani\u00e8re suivante dans un terminal : export FLASK_APP=hello.py . Une fois cela fait, lancer le serveur avec la commande : flask run --host=0.0.0.0 . Le --host=0.0.0.0 rend l'acc\u00e8s au serveur publique depuis d'autres appareils connect\u00e9s sur le r\u00e9seau. Dans mon cas, mon Raspberry Pi a cette adresse IP : 10.5.50.42 et mon PC 10.5.50.52 . Pour aller sur le site, je tape l'adresse IP du Raspberry Pi ainsi que le port 5000, http://10.5.50.42:5000/. * Serving Flask app \"hello.py\" * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 127.0.0.1 - - [28/Apr/2021 08:42:15] \"GET / HTTP/1.1\" 200 - 127.0.0.1 - - [28/Apr/2021 08:42:16] \"GET /favicon.ico HTTP/1.1\" 404 - 10.5.50.52 - - [28/Apr/2021 08:42:32] \"GET / HTTP/1.1\" 200 - 10.5.50.52 - - [28/Apr/2021 08:42:32] \"GET /favicon.ico HTTP/1.1\" 404 - Le port 5000 \u00e9tant le port par d\u00e9faut d\u00e9finit par Flask mais qui est changeable avec le param\u00e8tre flask run --host=0.0.0.0 -p 8000 , dans ce cas, le port de Flask sera chang\u00e9 \u00e0 8000. Routes Flask fonctionne avec un syst\u00e8me de routes. Les routes sont \u00e9crites de la mani\u00e8re suivantes : @app.route('/nom_de_la_route') def nom_de_la_fonction(): # Code ... return html_a_afficher Lors de l'acc\u00e8s \u00e0 une route, le code \u00e0 l'int\u00e9rieur de la fonction sera ex\u00e9cut\u00e9e puis rendra de l'HTML \u00e0 afficher. On peut aussi r\u00e9cup\u00e9rer une valeur depuis la route de la mani\u00e8re suivante : @app.route('/hello/<name>') def hello(param_name): return render_template('hello.html', name=param_name) Templates Si les routes rendent de l'HTML, c'est que l'on peut inj\u00e9cter des valeurs dans du code HTML pr\u00e9-\u00e9cris. Pour ce faire, \u00e0 la racine du projet, il faut cr\u00e9er une dossier pr\u00e9cis\u00e9ment nomm\u00e9 de la sorte : templates . Ce r\u00e9pertoire contiendra les diff\u00e9rents templates HTML \u00e0 afficher. Voici comment un fichier de template HTML est \u00e9crit : <!doctype html> <title>Hello from Flask</title> {% if name %} <h1>Hello {{ name }}!</h1> {% else %} <h1>Hello, World!</h1> {% endif %} Les balises {% ... %} permettent d'\u00e9crire du code comme des tests et des boucles. Les balises {{ nom_de_la_variable }} permettent d'injecter des valeurs dans l'HTML dynamiquement. Depuis le code python, pour pouvoir utiliser des templates, il faut importer render_template comme suit : from flask import render_template Formulaires Les formulaires avec Flask sont \u00e9crit en HTML classique : <form action=\"/route_apres_validation\" method=\"POST ou GET\"> <input type=\"text\" name=\"input_txt\" placeholder=\"...\"/> <input type=\"checkbox\" name=\"input_cbx\" checked=\"true\"/> <input type=\"submit\" value=\"valider\" name=\"input_validation\" /> </form> Pour r\u00e9cup\u00e9rer les informations des diff\u00e9rents champs du fomulaire, voici le code qui permet de les r\u00e9cup\u00e9rer : @app.route('/route_apres_validation', methods=['GET', 'POST']) def nom_de_fonction(): if request.method == 'POST' and request.form[\"input_validation\"]: valeur = request.form[\"nom_input_html\"] # Traitement ... return html_a_afficher Dans le param\u00e8tre methods de la route, la param\u00e8tre GET est celui de base mais peut \u00eatre chang\u00e9 par POST. Bluetooth Qu'est-ce que le bluetooth ? Le bluetooth est norme de communication \u00e0 courte distance utilisant des ondes radios sur la bande de fr\u00e9quence 2,4GHz. Ce qui permet d'\u00e9changer des donn\u00e9es dans les deux sens en peer-to-peer dans un picor\u00e9seau. Un picor\u00e9seau (en anglais piconet) est un mini-r\u00e9seau qui se cr\u00e9e de mani\u00e8re instantan\u00e9e et automatique quand plusieurs p\u00e9riph\u00e9riques Bluetooth sont dans un m\u00eame rayon. Comment est-il structur\u00e9 ? Quand on parle de bluetooth, au niveau des protocoles, on peut parler de relations Ma\u00eetres et d' Esclaves . Le Ma\u00eetre Bluetooth est celui qui peut initier une connexion avec un p\u00e9riph\u00e9rique (ou Esclave ), cependant une fois les appareils connect\u00e9s, le Ma\u00eetre et l' Esclave peuvent \u00e9changer des informations sans restriction (en fonction de la limitation de l'application). Les relations Ma\u00eetre - Esclave sont g\u00e9r\u00e9es par le gestionnaire de liason. Il impl\u00e9mente le protocole L2CAP (de l'anglais Logical Link Control and Adaptation Protocol ) et le g\u00e8re (cr\u00e9ation, destruction de canaux). Il impl\u00e9mente aussi les m\u00e9canismes de s\u00e9curit\u00e9 comme : l'authentification l'appairage (l'association) la cr\u00e9ation et la modification des cl\u00e9s et le chiffrement S\u00e9curit\u00e9 Il exite 3 modes de s\u00e9curit\u00e9 : Mode 1 Non s\u00e9curis\u00e9 pour toutes op\u00e9rations Peut uniquement communiquer avec des appareils du m\u00eame mode Mode 2 Fournit un niveau de s\u00e9curit\u00e9 \u00e0 la couche application apr\u00e8s l'\u00e9tablissement d'une liaison avec un autre dispositif Mode 3 Fournit un niveau de s\u00e9curit\u00e9 avant l'\u00e9tablissement du canal de communication Chiffrement s\u00e9curis\u00e9 au niveau de la liaison avec autre dispositif \u00c0 noter, si un service effectue une demande de connexion, le mode de s\u00e9curit\u00e9 les plus haut sera celui utilis\u00e9 afin de traiter la demande toute en s'assurant de la s\u00e9curit\u00e9 relatives au diff\u00e9rents modes. Le bluetooth est divis\u00e9 en deux parties : La couche contr\u00f4leur impl\u00e9mentant la partie mat\u00e9rielle la couche h\u00f4te impl\u00e9mentant la partie logicielle. L'\u00e9mission et la r\u00e9ception de signaux radio sont possible gr\u00e2ce \u00e0 un module RF (RadioFrequency). L'interface host-controller (HCI) fait la liaison entre la couche h\u00f4te et la couche contr\u00f4leur en assurant le transfert des \u00e9v\u00e9nements et des paquets de donn\u00e9es. Cette interface assure le transfert d\u2019information pour que la couche h\u00f4te puisse d\u00e9couvrir, ajouter et g\u00e9rer les appareils dans un picor\u00e9seau. Chaque paquets poss\u00e8dent un champ header permettant de distinguer le picor\u00e9seau de l\u2019appareil des autres picor\u00e9seaux. Voici le format d'un paquet : Champ Header Access Address Protocol Data Unit (PDU) Cyclic redundancy Check (CRC) Taille en bits 8 32 de 2 \u00e0 39 24 Le PDU est une unit\u00e9 de mesure des informations \u00e9chang\u00e9es dans un r\u00e9seau informatique. Appliqu\u00e9 aux couches du mod\u00e8le OSI, le PDU de : La couche physique est le bit. La couche liaison est la trame. La couche r\u00e9seau est le paquet. La couche transport est le segment pour TCP, et le datagramme pour UDP. Les couches application, pr\u00e9sentation et session sont les donn\u00e9es. Le Cyclic Redundancy Check, autrement appel\u00e9 contr\u00f4le de redondance cyclique, permet de d\u00e9tecter des erreurs de transmission ou de transfert par ajout, combinaison et comparaison de donn\u00e9es redondantes, obtenues gr\u00e2ce \u00e0 une proc\u00e9dure de hachage. Cette m\u00e9thode est comparable au checksum, mais ce dernier est plus \u00e9labor\u00e9. Les paquets re\u00e7us par le HCI sont trait\u00e9s par le protocole L2CAP. Il assure le transport des paquets vers les couches sup\u00e9rieures du mod\u00e8le OSI, la segmentation et le r\u00e9-assemblage des paquets. La couche de liaison est d\u00e9finie dans les syst\u00e8mes bluetooth comme la couche assurant le transport des paquets entre les appareils d\u2019un m\u00eame picor\u00e9seau \u00e0 travers plusieurs canaux : Basic channel : Canal pour la communication entre deux appareils Adapted piconet channel : Canal pour la communication dans le picor\u00e9seau Inquiry scan : Canal pour l'acquisition des appareils bluetooth aux alentours Page scan : Canal pour la connexion avec un nouvel appareil Qu'est-ce que Generic Access Profile Generic Access Profile (GAP), est responsable de la connexion. De plus , il g\u00e8re aussi : les modes d'acc\u00e8s les proc\u00e9dures du dispositif la d\u00e9couverte du dispositif l'\u00e9tablissement et la fin de la liaison le lancement des fonctions de s\u00e9curit\u00e9 la configuration du dispositif. Veille : le dispositif est dans l'\u00e9tat initial de veille lors de la r\u00e9initialisation. Annonce : Le dispositif envoie un message d'annonce avec des donn\u00e9es sp\u00e9cifiques pour faire savoir aux dispositifs initiateurs qu'il est un dispositif connectable (cette annonce contient l'adresse du dispositif et peut contenir des donn\u00e9es suppl\u00e9mentaires telles que le nom du dispositif). Scan : Lorsqu'il re\u00e7oit l'annonce, le dispositif de scan envoie une demande de scan \u00e0 l'annonceur qui r\u00e9pondra par une r\u00e9ponse d'analyse. Cette m\u00e9thode est appel\u00e9 d\u00e9couverte du dispositif. Le dispositif d'analyse conna\u00eet le dispositif ayant \u00e9mit l'annonce et peut \u00e9tablir une connexion avec lui. Initiation : Lors de l'initialisation, l'initiateur doit sp\u00e9cifier une adresse de dispositif homologue \u00e0 laquelle se connecter. S'il re\u00e7oit une annonce correspondant \u00e0 l'adresse du dispositif homologue, le dispositif initiateur envoie une demande de connexion avec les param\u00e8tres disponible ci-dessous : Intervale de connexion (entre 7.5 et 3200 ms) La latence de l'esclave D\u00e9lai de supervision (entre 10 et 3200 ms) Esclave/Ma\u00eetre : Lorsqu'une connexion est \u00e9tablie, le dispositif fonctionne comme un esclave s'il s'agit de l'annonceur sinon comme un ma\u00eetre s'il s'agit de l'initiateur. Qu'est-ce que Generic Attribute Profile Generic Attribute Profile (GATT), est responsable de la communications de donn\u00e9es entre les appareils connect\u00e9s. Il est structur\u00e9 en Services et Characteristics comme ci-dessous : Les attributs sont group\u00e9s en services , chaque services peut contenir 0 ou + characteristics . Ces derni\u00e8res peuvent avoir de 0 \u00e0 + descriptors . GATT Server : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown ervice) Characteristic : Unknown Charateristic Pour avoir acc\u00e8s \u00e0 ces informations, j'ai utilis\u00e9 l'application EFRConnect disponible sur le playstore. J'ai lanc\u00e9 un scan depuis le Raspberry Pi, voici les informations qui f\u00fbt retourn\u00e9e : [NEW] Device 90:84:2B:50:36:43 Technic Hub [CHG] Device 90:84:2B:50:36:43 RSSI: -58 [CHG] Device 90:84:2B:50:36:43 TxPower: 0 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: 00 80 06 00 61 00 ....a. Par la suite, j'ai lanc\u00e9 un scan depuis l'application afin de comparer les donn\u00e9es, voici les informations que l'application m'a retroun\u00e9e concernant le Technic Hub : Flags : 0x06: LE General Discoverable Mode, BR/EDR Not Supported Complete list of 128-bit service class UUIDs : 00001624-1212-EFDE-1623-785FEABCD123 Manufacturer Data : Company Code : 0x0397 Data : 0x008006004100 Slave connection interval range : 20.0ms Tx power level: 0 dBm Complete local name : Technic Hub Generic attribute : 0x1801 UUID : 0x2A05 Descriptor : champs vide Client characteristic configuration : 0x2902 Generic access : Device name : 0x1800 Appearance : 0x2A01 Peripheral preffered connection parameters : 0x2A04 Unknown Service : UUID : 00001624-1212-EFDE-1623-785FEABCD123 Descriptor : champs vide Client characteristic configuration : 0x2902 Value : 05 00 04 03 00 2E 00 00 10 00 00 00 10 00 00 00 00 00 00 00 T'chat en bluetooth Mise en place Il faut que les 2 Raspberry Pi soit en mode \"D\u00e9couvrable\" activable ici : . Il faut ensuite effectuer un scan des appareils si nous ne connaissons pas le nom d'h\u00f4te de l'autre Raspberry Pi. Le script doit \u00eatre pr\u00e9sent sur les deux Raspberry Pi afin de pouvoir \u00e9couter, recevoir ainsi qu'envoyer des messages. La machine h\u00f4te, moi dans ce contexte, doit \u00eatre en mode MODE_SEND tandis que l'autre en mode MODE_RECEIVE. Utilisation Le code fonctionne de la mani\u00e8re suivante. La machine h\u00f4te va en premier temps lancer le scan \u00e0 la recherche de l'appareil nomm\u00e9 morenoPi42 . Une fois l'appareil trouv\u00e9, je m'y appareille, puis lui envoie le premier message. Le mode actuel, change et je deviens la machine qui \u00e9coute le port sp\u00e9cifi\u00e9 en attendant un message. Dates importantes Lundi 19 avril 2021 : D\u00e9but du travail de dipl\u00f4me Vendredi 30 avril 2021 : \u00c9valuation interm\u00e9diaire 1 Vendredi 14 mai 2021 : Rendu du rapport interm\u00e9diaire + poster Vendredi 14 mai 2021 : Rendu version interm\u00e9diaire du r\u00e9sum\u00e9 et de l\u2019abstract (pour conseils par l\u2019enseignant d\u2019anglais) Lundi 17 mai 2021 : \u00c9valuation interm\u00e9diaire 2 Jeudi 20 mai 2021 apr\u00e8s-midi : Soir\u00e9e poster : amis, famille, CFC, experts 14h00 : Visite des classes de 1re ann\u00e9e (cf. SG) 16h30 : Amis, famille, experts, enseignants Tech ES\u2026 18h00 : Fin de la soir\u00e9e poster Lundi 31 mai 2021 : \u00c9valuation interm\u00e9diaire 3 Vendredi 11 juin 2021 : Rendu du travail avant 12h00 Jeudi 17 juin 2021 : D\u00e9fenses \u00e0 blanc + harmonisation des notes Lundi 21 juin ou mardi 22 juin 2021 : D\u00e9fenses de dipl\u00f4me Retour d'exp\u00e9rience Probl\u00e8mes rencontr\u00e9s R\u00e9sultat Ce qu'il reste \u00e0 faire Am\u00e9liorations possibles Bilan personnel Apports personnels Conclusion Journal de bord Glossaire Code source","title":"Documentation technique de _Voiture Assist\u00e9e_"},{"location":"documentation_technique/#documentation-technique-de-voiture-assistee","text":"","title":"Documentation technique de Voiture Assist\u00e9e"},{"location":"documentation_technique/#resume","text":"Voiture assist\u00e9e est un projet d'\u00e9tude portant sur les voitures autonomes et leurs fonctionnement. Ce projet me f\u00fbt propos\u00e9 par M. Bonvin \u00e9tant donn\u00e9 que la premi\u00e8re \u00e9bauche du cahier des charges comportait en une simulation de voiture autonome mais ce dans une application windows form. M. Bonvin ayant entendu parler de mon projet, il a s\u00fb amener un c\u00f4t\u00e9 plus int\u00e9ressant et professionnel dans le travail que je vais devoir r\u00e9aliser. \u00c9tant donn\u00e9 la d\u00e9couverte des diff\u00e9rents appareils utilis\u00e9 pour ce projet, la plus value sera surtout l'acquisition de nouvelles connaissances dans le domaine de l'informatique physique. Par cons\u00e9quent, le but du projet est de r\u00e9aliser une voiture se d\u00e9pla\u00e7able \u00e0 l'aide une interface web et qui sait se d\u00e9placer par elle m\u00eame en \u00e9vitant les obstacles sur sa route.","title":"R\u00e9sum\u00e9"},{"location":"documentation_technique/#abstract","text":"Voiture assist\u00e9e is a study project about autonomous cars and their functioning. This project was proposed to me by Mr. Bonvin since the first draft of the specifications included a simulation of an autonomous car but in a windows form application. Mr. Bonvin heard about my project, he knew how to bring a more interesting and professional side in the work that I will have to realize. Considering the discovery of the different devices used for this project, the added value will be especially the acquisition of new knowledge in the field of physical computing. Therefore, the goal of the project is to realize a car that can be moved by a web interface and that knows how to move by itself and which avoids obstacles on its way.","title":"Abstract"},{"location":"documentation_technique/#poster","text":"","title":"Poster"},{"location":"documentation_technique/#cahier-des-charges","text":"","title":"Cahier des charges"},{"location":"documentation_technique/#titre-du-projet","text":"Le titre du projet est Voiture assist\u00e9e car le but du projet est d'en r\u00e9aliser une.","title":"Titre du projet"},{"location":"documentation_technique/#contexte","text":"Ce projet m'a \u00e9t\u00e9 propos\u00e9 par M. Bonvin car il a vu que j'allais faire une simulation de voiture autonome, il s'est dit que l'on pourrait tourner la chose autrement. Il a une multitude de Raspberry Pi, de composants ainsi qu'une voiture LEGO controlable. C'est pourquoi il m'a dirig\u00e9 vers une programmation utilisant des capteurs et du bluetooth.","title":"Contexte"},{"location":"documentation_technique/#objectif","text":"L'objectif principale de ce projet est de r\u00e9aliser une voiture capable de se d\u00e9placer d'un point A \u00e0 un point B en \u00e9vitant les diff\u00e9rents obstacles sur sa route. Pour ce faire, il faudra trouver un moyen de communiquer avec le Technic Hub afin de mouvoir la voiture. Ensuite, il faudra faire fonctionner ind\u00e9pendamment les diff\u00e9rents capteurs. Pour ensuite cr\u00e9er un algorithme \u00e9v\u00e9nementiel g\u00e9rant les diff\u00e9rentes pond\u00e9rations des messages que les capteurs enverront.","title":"Objectif"},{"location":"documentation_technique/#technologies-et-materiels-utilises","text":"","title":"Technologies et mat\u00e9riels utilis\u00e9s"},{"location":"documentation_technique/#logiciels","text":"Visual Studio Code Python Flask Github Markdown QCAD Photoshop CS6 Pencil","title":"Logiciels"},{"location":"documentation_technique/#materiels","text":"Raspberry Pi 0 WiFi Raspberry Pi 4B 2 Cam\u00e9ra infrarouges (PI NoIR) 4 phares (Bright Pi v1.0) GPS (Ultimate GPS Breakout v3) \u00c9metteur WiFi (ASUS RT-AC58U) LEGO 4x4 X-trem Off-Roader D\u00e9tecteur infrarouge (Flying-Fish) Radar 360 (RPLiDAR A2M8)","title":"Mat\u00e9riels"},{"location":"documentation_technique/#environnement-de-developpement","text":"Pour me connecter au Raspberry Pi sur lequel je travail, j'utilise : Remote SSH pour \u00e9diter le code Il s'agit d'une extension Visual Studio Code disponible ici Github pour publi\u00e9 mon code \u00e9crit sur le Raspberry Pi et pour mettre \u00e0 disposition la documentation technique ainsi que le journal de bord RealVNC pour me connecter \u00e0 distance \u00e0 l'interface graphique du Raspberry Pi Il s'agit d'un logiciel cr\u00e9ant un serveur et un client permettant de contr\u00f4ler \u00e0 distance l'\u00e9cran d'un autre ordinateur, disponible ici .","title":"Environnement de d\u00e9veloppement"},{"location":"documentation_technique/#description-detaillee-de-ce-que-lapplication-fait","text":"La voiture est t\u00e9l\u00e9commandable \u00e0 distance \u00e0 l'aide d'une interface web. Sur le site internet, on a acc\u00e8s \u00e0 l'\u00e9tat des diff\u00e9rents capteurs ainsi que les donn\u00e9es qu'ils envoient.","title":"Description d\u00e9taill\u00e9e de ce que l'application fait"},{"location":"documentation_technique/#plans-de-la-voiture","text":"Dans le croquis du plan de la voiture pr\u00e9sent ci-dessus, je vais \u00e9nonc\u00e9 le r\u00f4le de chaque composant. Les phares sont repr\u00e9sent\u00e9 par le Bright Pi Les d\u00e9tecteurs de sol plac\u00e9s au niveau des roues sont repr\u00e9sent\u00e9 par le Flying-Fish Le Raspberry Pi 4 est repr\u00e9sent\u00e9 par RSP 4 Le Raspberry Pi 0 WiFi est repr\u00e9sent\u00e9 par RSP 0 W Le scanner 360\u00b0 est repr\u00e9sent\u00e9 par le Lidar En comparaison, voici de quoi est \u00e9quip\u00e9e une vraie voiture autonome :","title":"Plans de la voiture"},{"location":"documentation_technique/#schema-explicatif-de-lapplication","text":"L'application offre plusieurs pages.","title":"Sch\u00e9ma explicatif de l'application"},{"location":"documentation_technique/#interface-utilisateur-de-lapplication","text":"Une page d'interface utilisateur, pour avoir acc\u00e8s aux informations des capteurs ainsi que leurs \u00e9tats.","title":"Interface utilisateur de l'application"},{"location":"documentation_technique/#interface-telecommande","text":"Une page de t\u00e9l\u00e9commande pour la voiture.","title":"Interface t\u00e9l\u00e9commande"},{"location":"documentation_technique/#en-mode-manuel","text":"L'utilisateur d\u00e9place la voiture \u00e0 l'aide de la manette disponible sur le site web.","title":"En mode manuel"},{"location":"documentation_technique/#en-mode-automatique","text":"La voiture se d\u00e9place de mani\u00e8re rectiligne en \u00e9vitant les obstacles sur sa route.","title":"En mode automatique"},{"location":"documentation_technique/#contact","text":"Status Nom Pr\u00e9nom Email Num\u00e9ro de t\u00e9l\u00e9phone \u00c9l\u00e8ve Ackermann Gawen gawen.ackrm@eduge.ch +41 79 88 98 69 4 Professeur de dipl\u00f4me Bonvin Pascal edu-bonvinp@eduge.ch +33 6 32 17 84 11","title":"Contact"},{"location":"documentation_technique/#structure-du-projet","text":"\u251c\u2500\u2500 code \u2502 \u251c\u2500\u2500 Bluetooth \u2502 \u251c\u2500\u2500 Bright Pi \u2502 \u251c\u2500\u2500 Camera \u2502 \u251c\u2500\u2500 Flask \u2502 \u251c\u2500\u2500 Lidar \u2502 \u2514\u2500\u2500 OpenCV \u251c\u2500\u2500 docs \u2502 \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 plans \u2502 \u251c\u2500\u2500 documentation_technique.md \u2502 \u251c\u2500\u2500 index.md \u2502 \u251c\u2500\u2500 logbook.md \u2502 \u2514\u2500\u2500 requirements.txt \u251c\u2500\u2500 site \u2502 \u251c\u2500\u2500 assets \u2502 \u251c\u2500\u2500 documentation_technique \u2502 \u251c\u2500\u2500 images \u2502 \u251c\u2500\u2500 logbook \u2502 \u251c\u2500\u2500 plans \u2502 \u251c\u2500\u2500 search \u2502 \u251c\u2500\u2500 404.html \u2502 \u251c\u2500\u2500 index.html \u2502 \u251c\u2500\u2500 sitemap.xml \u2502 \u2514\u2500\u2500 sitemap.xml.gz \u251c\u2500\u2500 mkdocs.yml \u2514\u2500\u2500 README.md","title":"Structure du projet"},{"location":"documentation_technique/#developpement","text":"","title":"D\u00e9veloppement"},{"location":"documentation_technique/#description-detaillee-de-chaques-capteurs","text":"","title":"Description d\u00e9taill\u00e9e de chaques capteurs"},{"location":"documentation_technique/#raspberry-pi","text":"Il s'agit d'un mini ordinateur de la taille d'une carte de cr\u00e9dit \u00e9quip\u00e9s de diff\u00e9rents capteurs, cela d\u00e9pends du mod\u00e8le.","title":"Raspberry Pi"},{"location":"documentation_technique/#mise-en-place","text":"En fonction du mod\u00e8le du Raspberry Pi il faut flasher les cartes SD avec diff\u00e9rents OS avec le Raspberry Pi Imager : Pour un Raspberry Pi 4, install\u00e9 la version Raspberry Pi OS Full (32-bit) pour faire les tests \u00e0 l'aide d'une interface graphique Pour un Raspberry 0 WiFi, install\u00e9 la version Raspberry Pi OS Lite (32-bit) utilis\u00e9 juste pour transiter des donn\u00e9es","title":"Mise en place"},{"location":"documentation_technique/#utilisation","text":"Un Raspberry Pi 4B est constitu\u00e9 des diff\u00e9rents \u00e9l\u00e9ments : Pour le GPIO, voici les pins disponibles : \u00c0 noter, la pin num\u00e9ro 1 se situe \u00e0 c\u00f4t\u00e9 du module Bluetooth tandis que la pin 39 se situe en diagonal du PoE HAT Header .","title":"Utilisation"},{"location":"documentation_technique/#camera","text":"La cam\u00e9ra est un module permettant d'avoir acc\u00e8s \u00e0 un flux vid\u00e9o.","title":"Cam\u00e9ra"},{"location":"documentation_technique/#mise-en-place_1","text":"J\u2019ai utilis\u00e9 le guide de la cam\u00e9ra disponible sur https://magpi.raspberrypi.org/books. Pour commencer, j\u2019ai activ\u00e9 la cam\u00e9ra dans le panneau de configuration du Raspberry Pi, puis j\u2019ai branch\u00e9 la cam\u00e9ra dans l\u2019emplacement pr\u00e9vu qui se situe entre la prise jack et les ports HDMI. Le ruban de la cam\u00e9ra doit \u00eatre plac\u00e9 de sorte \u00e0 ce que la languette bleue fasse face \u00e0 la prise jack. Pour m\u2019assurer que la cam\u00e9ra soit fonctionnelle, j\u2019utilise la commande suivante pour prendre une photo raspistill -o test.jpg","title":"Mise en place"},{"location":"documentation_technique/#utilisation_1","text":"Pour v\u00e9rifier qu'un flux vid\u00e9o pouvait \u00eatre lu, j'ai utilis\u00e9 le code ci dessous : from picamera import PiCamera from time import sleep camera = PiCamera() camera.start_preview() sleep(5) camera.stop_preview() \u00c0 noter, il est n\u00e9cessaire d'ex\u00e9cuter ce code depuis le Raspberry Pi et non par VNC, car l'affichage de la pr\u00e9visualisation du flux ne s'affiche pas. D'apr\u00e8s ce post disponible sur StackEchange, il semblerait que l'aper\u00e7u de la cam\u00e9ra soit g\u00e9r\u00e9 \u00e0 un bas niveau dans le processeur graphique et par cons\u00e9quent n'est visible que par le moniteur directement branch\u00e9 au Raspberry Pi.","title":"Utilisation"},{"location":"documentation_technique/#phare-bright-pi-v10","text":"Le Bright Pi est un module comportant 4 leds infrarouges situ\u00e9es aux extr\u00e9mit\u00e9es et au centre 8 leds.","title":"Phare (Bright Pi v1.0)"},{"location":"documentation_technique/#mise-en-place_2","text":"Pour l\u2019utilisation du Bright Pi, je me suis bas\u00e9 sur le guide disponible \u00e0 l\u2019adresse suivante : https://learn.pi-supply.com/make/bright-pi-quickstart-faq/. J\u2019ai commenc\u00e9 par activer l\u2019I2C dans le panneau de configuration du Raspberry Pi puis j\u2019ai branch\u00e9 les pins aux emplacements indiqu\u00e9s dans le guide de d\u00e9marrage. Les couleurs ci-dessous doivent \u00eatre respect\u00e9es (pour le placement uniquement). Pour s'assurer que le branchement soit correct, il est n\u00e9cessaire d'utiliser la commande i2cdetect -y 1 . Ceci devrait \u00eatre affich\u00e9 dans la console : Pour tester le Bright Pi, il est n\u00e9cessaire d'avoir le kit de d\u00e9veloppement disponible sur ce repos Github .","title":"Mise en place"},{"location":"documentation_technique/#utilisation_2","text":"Une fois cela fait, il faut importer les \u00e9l\u00e9ments concernant le brightpi avec from brightpi import * import time Pour faire clignoter les leds manuellement (\u00e0 l\u2019aide de lignes de code) j\u2019aurai pu utiliser l\u2019objet BrightPi, mais j\u2019ai finalement utilis\u00e9 le BrightPiSpecialEffects, car il permet d\u2019avoir acc\u00e8s \u00e0 des fonctions pr\u00e9d\u00e9finies concernant la manipulation des leds, par exemple \u00e0 les faire s\u2019allumer une \u00e0 une dans le sens des aiguilles d\u2019une montre, ce qui peut devenir utile par la suite du travail. Voici le code que j'ai \u00e9crit. Ce code permet de faire clignoter les leds d'un c\u00f4t\u00e9 sp\u00e9cifi\u00e9. def blink(repetitions, speed, right_leds, left_leds, side): # fait clignoter les leds des c\u00f4t\u00e9s sp\u00e9cifi\u00e9s duration = speed / 2 leds_to_activate = [] leds_to_desactivate = [] for i in range(0, repetitions): if side == \"L\": leds_to_activate = left_leds leds_to_desactivate = right_leds if side == \"R\": leds_to_activate = right_leds leds_to_desactivate = left_leds bright_special.set_led_on_off(leds_to_desactivate, OFF) bright_special.set_led_on_off(leds_to_activate, ON) time.sleep(duration) bright_special.set_led_on_off(leds_to_activate, OFF) time.sleep(duration) bright_special = BrightPiSpecialEffects() bright_special.reset() RIGHT_LEDS = [1, 2] LEFT_LEDS = [3, 4] blink(10, 1, RIGHT_LEDS, LEFT_LEDS, \"R\")","title":"Utilisation"},{"location":"documentation_technique/#gps-ultimate-gps-breakout-v3","text":"","title":"GPS (Ultimate GPS Breakout v3)"},{"location":"documentation_technique/#mise-en-place_3","text":"","title":"Mise en place"},{"location":"documentation_technique/#utilisation_3","text":"","title":"Utilisation"},{"location":"documentation_technique/#detecteur-infrarouge-flying-fish","text":"Le Flying-Fish est un module comportant 2 leds infrarouges, une qui \u00e9met et une autre qui re\u00e7ois. Il est \u00e9quip\u00e9 d'un potentiom\u00e8tre r\u00e9glant la distance d'\u00e9mission.","title":"D\u00e9tecteur infrarouge (Flying-Fish)"},{"location":"documentation_technique/#mise-en-place_4","text":"Comme le montre ce sch\u00e9ma, le Flying-Fish doit \u00eatre connect\u00e9 \u00e0 une alimentation ainsi qu'\u00e0 un Ground (appel\u00e9 Terre en fran\u00e7ais). La derni\u00e8re broche est la sortie. C'est-\u00e0-dire que lorsque la distance d'\u00e9mission regl\u00e9e \u00e0 l'aide du potentiom\u00e8tre est d\u00e9pass\u00e9e, la lumi\u00e8re d'obstacle s'\u00e9teindra et cette broche enverra un signal \u00e9lectrique informant du changement d'\u00e9tat.","title":"Mise en place"},{"location":"documentation_technique/#utilisation_4","text":"C'est pourquoi, j'ai branch\u00e9 le Vcc sur la pin 1 du GPIO, car le voltage accept\u00e9 est compris entre 3 et 6 Volts, ensuite j'ai branch\u00e9 le Gnd sur la pin 6. Je n'ai pas encore branch\u00e9 le Out \u00e9tant donn\u00e9 que je ne sais pas encore ou je dois le brancher exactement afin de r\u00e9cup\u00e9rer le signal dans le Raspberry.","title":"Utilisation"},{"location":"documentation_technique/#connexion-bluetooth-avec-le-lego-4x4-x-trem-off-roader","text":"Le LEGO 4x4 X-trem Off-Roader est une voiture t\u00e9l\u00e9commandable en bluetooth.","title":"Connexion bluetooth avec le LEGO 4x4 X-trem Off-Roader"},{"location":"documentation_technique/#mise-en-place_5","text":"Dans un premier temps, il faut installer bleak , pygatt et bluepy pour ce faire, j'ai utilis\u00e9 cette commande : sudo pip3 install pygatt && pip3 install gatt && pip3 install gattlib && pip3 install bluepy && pip3 install bleak puis j'ai t\u00e9l\u00e9charger le code sources du repository pylgbst . Pour tester la connexion bluetooth, j'ai lanc\u00e9 la commande sudo bluetoothctl , ensuite j'ai lanc\u00e9 les commandes suivantes : power on pour m'assurer que le service soit actif, puis scan on . Une fois que des appareils on \u00e9t\u00e9 d\u00e9tect\u00e9s, on peut lancer l'interface graphique situ\u00e9e dans la barre des t\u00e2ches : ou il est possible d'aller dans les pr\u00e9f\u00e9rences pour l'ouvrir : . Une fois cette interface ouverte, il faut cliquer sur le bouton Rechercher , ce qui effectura un scan des alentours. Une fois le Technic Hub trouv\u00e9 dans la liste, il est n\u00e9cessaire de noter son adresse mac : 90:84:2B:50:36:43 afin de pouvoir l'utiliser par la suite.","title":"Mise en place"},{"location":"documentation_technique/#utilisation_5","text":"Pour g\u00e9rer le d\u00e9placement de la voiture, \u00e0 l'aide du kit de d\u00e9veloppement fourit par pylgbst, voici le code que j'ai \u00e9crit : from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor, EncodedMotor from pylgbst import * from time import sleep MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" def forward(motor_1, motor_2, motor_3): motor_1.start_power(-1) motor_2.start_power(-1) motor_3.angled(0) print(\"done!\") def downward(motor_1, motor_2, motor_3): motor_1.start_power(1) motor_2.start_power(1) motor_3.angled(0) print(\"done!\") def go_left(motor_3): motor_3.angled(-180) print(\"done!\") def go_right(motor_3): motor_3.angled(180) print(\"done!\") def stop_moving(motor_1, motor_2): motor_1.start_power(0) motor_2.start_power(0) print(\"done!\") def reset_angle(motor_3): motor_3.angled(degrees=-150) print(\"test 1\") sleep(1) motor_3.angled(degrees=-75) print(\"test 2\") sleep(1) def play_scenario(movehub): motor_a = Motor(movehub, movehub.PORT_A) motor_b = Motor(movehub, movehub.PORT_B) motor_c = EncodedMotor(movehub, movehub.PORT_C) print(\"Reset angle:\") reset_angle(motor_c) sleep(2) print(\"Forward:\") forward(motor_a, motor_b, motor_c) sleep(1) print(\"Downward:\") downward(motor_a, motor_b, motor_c) sleep(1) print(\"Stop\") stop_moving(motor_a, motor_b) print(\"Left:\") go_left(motor_c) sleep(2) print(\"Right:\") go_right(motor_c) sleep(2) def exiting(connection): print(\"bye\") connection.disconnect() conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) play_scenario(movehub) exiting(conn) finally: exiting(conn) Le code fournit, propose diff\u00e9rentes m\u00e9thodes de connexion tel que : bluepy bluegiga gatt bleak gattool gattlib Ayant vu dans plusieurs documentations le nom de GATT ressortir, je m'y suis pench\u00e9 pour comprendre de quoi il s'agissait. GATT est un acronyme de l'anglais Generic Attribute Profile , il d\u00e9finit comment les 2 appareils vont \u00e9changer leurs donn\u00e9es, tout en suivant un syst\u00e8me de Services et de Characteristics . C'est pourquoi j'ai utilis\u00e9 la connexion avec GATT .","title":"Utilisation"},{"location":"documentation_technique/#probleme-rencontre","text":"Au d\u00e9part, je tentais d'appareiller le Raspberry Pi au Technic Hub depuis les commandes disponibles dans dans le mode bluetoothctl , mais j'avais cette erreur Failed to pair: org.bluez.Error.AuthenticationFailed . J'ai alors compris que pour me connecter au Technic hub, j'aurai besoin d'y avoir acc\u00e8s par un moyen qui permette de transmettre des donn\u00e9es car depuis la documentation LEGO, j'ai aper\u00e7u des commandes \u00e9crites avec des bytes en hexad\u00e9cimal. De plus,j'ai remarqu\u00e9 qu'ils mettaient \u00e0 disposition les UUID des hubs car ils ont tous le m\u00eame fabricant. Il y a plein de piste que j'ai entrevues sur les diff\u00e9rents repository, cependant je ne m'y \u00e9tais pas int\u00e9ress\u00e9 plus que \u00e7a, car aucun ne mentionnait le nom de Technic Hub. Apr\u00e8s avoir \u00e9t\u00e9 dans les diff\u00e9rents repository ci-dessous et apr\u00e8s avoir regard\u00e9 comment \u00e9taient \u00e9crit leurs transmission au hub bluetooth. J'ai r\u00e9ussi \u00e0 comprendre comment je pouvais m'appareiller au Technic Hub et comment int\u00e9ragir avec.","title":"Probl\u00e8me rencontr\u00e9"},{"location":"documentation_technique/#radar-360-rplidar-a2m8","text":"Le RPLiDAR A2M8 est un scanner laser \u00e0 360\u00b0. Il permet de conna\u00eetre la distance entre lui et les obstacles \u00e0 chaque angles.","title":"Radar 360 (RPLiDAR A2M8)"},{"location":"documentation_technique/#mise-en-place_6","text":"Le lidar est branchable par port s\u00e9rie. Cependant, un adaptateur est founie avec et nous permet de r\u00e9cup\u00e9rer les donn\u00e9es par USB. Au dos de l'adaptateur, on peut y voir les \u00e9l\u00e9ments suivants : Couleur du c\u00e2ble Nom du signal Type de signal Description Tension minimale Tension habituelle Tension maximale Rouge VCC Power Puissance totale 4.9V 5V 5.2V Vert TX Output Sortie des donn\u00e9es sur le port s\u00e9rie relative au scanner 0V 3.3V 3.5V Jaune RX Input Entr\u00e9e des donn\u00e9es sur le port s\u00e9rie relative au scanner 0V 3.3V 3.5V Noir GND Power La Terre 0V 0V 0V Bleu MOTOCTL Input Moteur de scan, r\u00e9gul\u00e9 avec un PWM 0V 3.3V 5V Informations compl\u00e9mentaires pour le PWM, voici les valeurs utilis\u00e9es : Unit\u00e9 Valeur minimale Valeur habituelle Valeur maximale Haut niveau de tension Volts 3.0 3.3 5 Fr\u00e9quence du PWM Herz 24,500 25,000 25,500 Plage de cycles d'utilisation Pourcent 0 60 100 Si on le souhaite, on peut modifier la vitesse de transmission. De base, la vitesse de transmission est param\u00e9tr\u00e9e sur 115'200 Baud mais on peut la mont\u00e9e \u00e0 256'000 Baud. Il faut commencer par t\u00e9l\u00e9charger le kit de d\u00e9veloppement disponible sur le repository officiel de Slamtec . Une fois le SDK t\u00e9l\u00e9charg\u00e9 sur le Raspberry. Nous pouvons brancher le Lidar \u00e0 l'adaptateur. Depuis l'adaptateur, branch\u00e9 le micro-USB dessus puis l'USB au Raspberry Pi.","title":"Mise en place"},{"location":"documentation_technique/#utilisation_6","text":"Afin de v\u00e9rifier qu'il soit bien d\u00e9tecter, il faut ex\u00e9cuter la commande suivante ls /dev/*USB* ceci devrait \u00eatre retourn\u00e9 /dev/ttyUSB0 . Dans le dossier du code source, il faut aller dans le r\u00e9pertoire sdk/app/ et ex\u00e9cuter la commande make dans un terminal. Pour ex\u00e9cuter l'un des 3 programmes suivant : ultra_simple simple_grabber frame_grabber Nous pouvons maintenant ex\u00e9cuter le programme souhait\u00e9 en utilisant la commande suivante dans un terminal : nom_du_programme /dev/ttyUSB0 .","title":"Utilisation"},{"location":"documentation_technique/#probleme-rencontre_1","text":"Les codes fournis fonctionnent parfaitement, sauf que aucun ne permet de r\u00e9cup\u00e9rer depuis une variable ou autre les valeurs d'angles. Cependant, elles sont affich\u00e9es dans la console.","title":"Probl\u00e8me rencontr\u00e9"},{"location":"documentation_technique/#emetteur-wifi-asus-rt-ac58u","text":"","title":"\u00c9metteur WiFi (ASUS RT-AC58U)"},{"location":"documentation_technique/#mise-en-place_7","text":"","title":"Mise en place"},{"location":"documentation_technique/#utilisation_7","text":"","title":"Utilisation"},{"location":"documentation_technique/#python-flask","text":"Flask est un framework web disponible en python qui permet de d\u00e9velopper ais\u00e9ment des applications web.","title":"Python Flask"},{"location":"documentation_technique/#mise-en-place_8","text":"Flask est t\u00e9l\u00e9chargeable depuis la commande pip3 install Flask .","title":"Mise en place"},{"location":"documentation_technique/#utilisation_8","text":"Dans un premier temps, il est important de cr\u00e9er une fichier python. Dans cet exemple, ce sera hello.py .","title":"Utilisation"},{"location":"documentation_technique/#application-de-base","text":"Il faut d'abord importer Flask. Et l'initialiser de la mani\u00e8re suivante : from flask import Flask app = Flask(__name__) @app.route('/') def hello_world(): return 'Hello, World!' Pour lancer l'application, il faut d'abord exporter la variable d'environnment FLASK_APP de la mani\u00e8re suivante dans un terminal : export FLASK_APP=hello.py . Une fois cela fait, lancer le serveur avec la commande : flask run --host=0.0.0.0 . Le --host=0.0.0.0 rend l'acc\u00e8s au serveur publique depuis d'autres appareils connect\u00e9s sur le r\u00e9seau. Dans mon cas, mon Raspberry Pi a cette adresse IP : 10.5.50.42 et mon PC 10.5.50.52 . Pour aller sur le site, je tape l'adresse IP du Raspberry Pi ainsi que le port 5000, http://10.5.50.42:5000/. * Serving Flask app \"hello.py\" * Environment: production WARNING: Do not use the development server in a production environment. Use a production WSGI server instead. * Debug mode: off * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit) 127.0.0.1 - - [28/Apr/2021 08:42:15] \"GET / HTTP/1.1\" 200 - 127.0.0.1 - - [28/Apr/2021 08:42:16] \"GET /favicon.ico HTTP/1.1\" 404 - 10.5.50.52 - - [28/Apr/2021 08:42:32] \"GET / HTTP/1.1\" 200 - 10.5.50.52 - - [28/Apr/2021 08:42:32] \"GET /favicon.ico HTTP/1.1\" 404 - Le port 5000 \u00e9tant le port par d\u00e9faut d\u00e9finit par Flask mais qui est changeable avec le param\u00e8tre flask run --host=0.0.0.0 -p 8000 , dans ce cas, le port de Flask sera chang\u00e9 \u00e0 8000.","title":"Application de base"},{"location":"documentation_technique/#routes","text":"Flask fonctionne avec un syst\u00e8me de routes. Les routes sont \u00e9crites de la mani\u00e8re suivantes : @app.route('/nom_de_la_route') def nom_de_la_fonction(): # Code ... return html_a_afficher Lors de l'acc\u00e8s \u00e0 une route, le code \u00e0 l'int\u00e9rieur de la fonction sera ex\u00e9cut\u00e9e puis rendra de l'HTML \u00e0 afficher. On peut aussi r\u00e9cup\u00e9rer une valeur depuis la route de la mani\u00e8re suivante : @app.route('/hello/<name>') def hello(param_name): return render_template('hello.html', name=param_name)","title":"Routes"},{"location":"documentation_technique/#templates","text":"Si les routes rendent de l'HTML, c'est que l'on peut inj\u00e9cter des valeurs dans du code HTML pr\u00e9-\u00e9cris. Pour ce faire, \u00e0 la racine du projet, il faut cr\u00e9er une dossier pr\u00e9cis\u00e9ment nomm\u00e9 de la sorte : templates . Ce r\u00e9pertoire contiendra les diff\u00e9rents templates HTML \u00e0 afficher. Voici comment un fichier de template HTML est \u00e9crit : <!doctype html> <title>Hello from Flask</title> {% if name %} <h1>Hello {{ name }}!</h1> {% else %} <h1>Hello, World!</h1> {% endif %} Les balises {% ... %} permettent d'\u00e9crire du code comme des tests et des boucles. Les balises {{ nom_de_la_variable }} permettent d'injecter des valeurs dans l'HTML dynamiquement. Depuis le code python, pour pouvoir utiliser des templates, il faut importer render_template comme suit : from flask import render_template","title":"Templates"},{"location":"documentation_technique/#formulaires","text":"Les formulaires avec Flask sont \u00e9crit en HTML classique : <form action=\"/route_apres_validation\" method=\"POST ou GET\"> <input type=\"text\" name=\"input_txt\" placeholder=\"...\"/> <input type=\"checkbox\" name=\"input_cbx\" checked=\"true\"/> <input type=\"submit\" value=\"valider\" name=\"input_validation\" /> </form> Pour r\u00e9cup\u00e9rer les informations des diff\u00e9rents champs du fomulaire, voici le code qui permet de les r\u00e9cup\u00e9rer : @app.route('/route_apres_validation', methods=['GET', 'POST']) def nom_de_fonction(): if request.method == 'POST' and request.form[\"input_validation\"]: valeur = request.form[\"nom_input_html\"] # Traitement ... return html_a_afficher Dans le param\u00e8tre methods de la route, la param\u00e8tre GET est celui de base mais peut \u00eatre chang\u00e9 par POST.","title":"Formulaires"},{"location":"documentation_technique/#bluetooth","text":"","title":"Bluetooth"},{"location":"documentation_technique/#quest-ce-que-le-bluetooth","text":"Le bluetooth est norme de communication \u00e0 courte distance utilisant des ondes radios sur la bande de fr\u00e9quence 2,4GHz. Ce qui permet d'\u00e9changer des donn\u00e9es dans les deux sens en peer-to-peer dans un picor\u00e9seau. Un picor\u00e9seau (en anglais piconet) est un mini-r\u00e9seau qui se cr\u00e9e de mani\u00e8re instantan\u00e9e et automatique quand plusieurs p\u00e9riph\u00e9riques Bluetooth sont dans un m\u00eame rayon.","title":"Qu'est-ce que le bluetooth ?"},{"location":"documentation_technique/#comment-est-il-structure","text":"Quand on parle de bluetooth, au niveau des protocoles, on peut parler de relations Ma\u00eetres et d' Esclaves . Le Ma\u00eetre Bluetooth est celui qui peut initier une connexion avec un p\u00e9riph\u00e9rique (ou Esclave ), cependant une fois les appareils connect\u00e9s, le Ma\u00eetre et l' Esclave peuvent \u00e9changer des informations sans restriction (en fonction de la limitation de l'application). Les relations Ma\u00eetre - Esclave sont g\u00e9r\u00e9es par le gestionnaire de liason. Il impl\u00e9mente le protocole L2CAP (de l'anglais Logical Link Control and Adaptation Protocol ) et le g\u00e8re (cr\u00e9ation, destruction de canaux). Il impl\u00e9mente aussi les m\u00e9canismes de s\u00e9curit\u00e9 comme : l'authentification l'appairage (l'association) la cr\u00e9ation et la modification des cl\u00e9s et le chiffrement","title":"Comment est-il structur\u00e9 ?"},{"location":"documentation_technique/#securite","text":"Il exite 3 modes de s\u00e9curit\u00e9 : Mode 1 Non s\u00e9curis\u00e9 pour toutes op\u00e9rations Peut uniquement communiquer avec des appareils du m\u00eame mode Mode 2 Fournit un niveau de s\u00e9curit\u00e9 \u00e0 la couche application apr\u00e8s l'\u00e9tablissement d'une liaison avec un autre dispositif Mode 3 Fournit un niveau de s\u00e9curit\u00e9 avant l'\u00e9tablissement du canal de communication Chiffrement s\u00e9curis\u00e9 au niveau de la liaison avec autre dispositif \u00c0 noter, si un service effectue une demande de connexion, le mode de s\u00e9curit\u00e9 les plus haut sera celui utilis\u00e9 afin de traiter la demande toute en s'assurant de la s\u00e9curit\u00e9 relatives au diff\u00e9rents modes. Le bluetooth est divis\u00e9 en deux parties : La couche contr\u00f4leur impl\u00e9mentant la partie mat\u00e9rielle la couche h\u00f4te impl\u00e9mentant la partie logicielle. L'\u00e9mission et la r\u00e9ception de signaux radio sont possible gr\u00e2ce \u00e0 un module RF (RadioFrequency). L'interface host-controller (HCI) fait la liaison entre la couche h\u00f4te et la couche contr\u00f4leur en assurant le transfert des \u00e9v\u00e9nements et des paquets de donn\u00e9es. Cette interface assure le transfert d\u2019information pour que la couche h\u00f4te puisse d\u00e9couvrir, ajouter et g\u00e9rer les appareils dans un picor\u00e9seau. Chaque paquets poss\u00e8dent un champ header permettant de distinguer le picor\u00e9seau de l\u2019appareil des autres picor\u00e9seaux. Voici le format d'un paquet : Champ Header Access Address Protocol Data Unit (PDU) Cyclic redundancy Check (CRC) Taille en bits 8 32 de 2 \u00e0 39 24 Le PDU est une unit\u00e9 de mesure des informations \u00e9chang\u00e9es dans un r\u00e9seau informatique. Appliqu\u00e9 aux couches du mod\u00e8le OSI, le PDU de : La couche physique est le bit. La couche liaison est la trame. La couche r\u00e9seau est le paquet. La couche transport est le segment pour TCP, et le datagramme pour UDP. Les couches application, pr\u00e9sentation et session sont les donn\u00e9es. Le Cyclic Redundancy Check, autrement appel\u00e9 contr\u00f4le de redondance cyclique, permet de d\u00e9tecter des erreurs de transmission ou de transfert par ajout, combinaison et comparaison de donn\u00e9es redondantes, obtenues gr\u00e2ce \u00e0 une proc\u00e9dure de hachage. Cette m\u00e9thode est comparable au checksum, mais ce dernier est plus \u00e9labor\u00e9. Les paquets re\u00e7us par le HCI sont trait\u00e9s par le protocole L2CAP. Il assure le transport des paquets vers les couches sup\u00e9rieures du mod\u00e8le OSI, la segmentation et le r\u00e9-assemblage des paquets. La couche de liaison est d\u00e9finie dans les syst\u00e8mes bluetooth comme la couche assurant le transport des paquets entre les appareils d\u2019un m\u00eame picor\u00e9seau \u00e0 travers plusieurs canaux : Basic channel : Canal pour la communication entre deux appareils Adapted piconet channel : Canal pour la communication dans le picor\u00e9seau Inquiry scan : Canal pour l'acquisition des appareils bluetooth aux alentours Page scan : Canal pour la connexion avec un nouvel appareil","title":"S\u00e9curit\u00e9"},{"location":"documentation_technique/#quest-ce-que-generic-access-profile","text":"Generic Access Profile (GAP), est responsable de la connexion. De plus , il g\u00e8re aussi : les modes d'acc\u00e8s les proc\u00e9dures du dispositif la d\u00e9couverte du dispositif l'\u00e9tablissement et la fin de la liaison le lancement des fonctions de s\u00e9curit\u00e9 la configuration du dispositif. Veille : le dispositif est dans l'\u00e9tat initial de veille lors de la r\u00e9initialisation. Annonce : Le dispositif envoie un message d'annonce avec des donn\u00e9es sp\u00e9cifiques pour faire savoir aux dispositifs initiateurs qu'il est un dispositif connectable (cette annonce contient l'adresse du dispositif et peut contenir des donn\u00e9es suppl\u00e9mentaires telles que le nom du dispositif). Scan : Lorsqu'il re\u00e7oit l'annonce, le dispositif de scan envoie une demande de scan \u00e0 l'annonceur qui r\u00e9pondra par une r\u00e9ponse d'analyse. Cette m\u00e9thode est appel\u00e9 d\u00e9couverte du dispositif. Le dispositif d'analyse conna\u00eet le dispositif ayant \u00e9mit l'annonce et peut \u00e9tablir une connexion avec lui. Initiation : Lors de l'initialisation, l'initiateur doit sp\u00e9cifier une adresse de dispositif homologue \u00e0 laquelle se connecter. S'il re\u00e7oit une annonce correspondant \u00e0 l'adresse du dispositif homologue, le dispositif initiateur envoie une demande de connexion avec les param\u00e8tres disponible ci-dessous : Intervale de connexion (entre 7.5 et 3200 ms) La latence de l'esclave D\u00e9lai de supervision (entre 10 et 3200 ms) Esclave/Ma\u00eetre : Lorsqu'une connexion est \u00e9tablie, le dispositif fonctionne comme un esclave s'il s'agit de l'annonceur sinon comme un ma\u00eetre s'il s'agit de l'initiateur.","title":"Qu'est-ce que Generic Access Profile"},{"location":"documentation_technique/#quest-ce-que-generic-attribute-profile","text":"Generic Attribute Profile (GATT), est responsable de la communications de donn\u00e9es entre les appareils connect\u00e9s. Il est structur\u00e9 en Services et Characteristics comme ci-dessous : Les attributs sont group\u00e9s en services , chaque services peut contenir 0 ou + characteristics . Ces derni\u00e8res peuvent avoir de 0 \u00e0 + descriptors . GATT Server : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown ervice) Characteristic : Unknown Charateristic Pour avoir acc\u00e8s \u00e0 ces informations, j'ai utilis\u00e9 l'application EFRConnect disponible sur le playstore. J'ai lanc\u00e9 un scan depuis le Raspberry Pi, voici les informations qui f\u00fbt retourn\u00e9e : [NEW] Device 90:84:2B:50:36:43 Technic Hub [CHG] Device 90:84:2B:50:36:43 RSSI: -58 [CHG] Device 90:84:2B:50:36:43 TxPower: 0 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: 00 80 06 00 61 00 ....a. Par la suite, j'ai lanc\u00e9 un scan depuis l'application afin de comparer les donn\u00e9es, voici les informations que l'application m'a retroun\u00e9e concernant le Technic Hub : Flags : 0x06: LE General Discoverable Mode, BR/EDR Not Supported Complete list of 128-bit service class UUIDs : 00001624-1212-EFDE-1623-785FEABCD123 Manufacturer Data : Company Code : 0x0397 Data : 0x008006004100 Slave connection interval range : 20.0ms Tx power level: 0 dBm Complete local name : Technic Hub Generic attribute : 0x1801 UUID : 0x2A05 Descriptor : champs vide Client characteristic configuration : 0x2902 Generic access : Device name : 0x1800 Appearance : 0x2A01 Peripheral preffered connection parameters : 0x2A04 Unknown Service : UUID : 00001624-1212-EFDE-1623-785FEABCD123 Descriptor : champs vide Client characteristic configuration : 0x2902 Value : 05 00 04 03 00 2E 00 00 10 00 00 00 10 00 00 00 00 00 00 00","title":"Qu'est-ce que Generic Attribute Profile"},{"location":"documentation_technique/#tchat-en-bluetooth","text":"","title":"T'chat en bluetooth"},{"location":"documentation_technique/#mise-en-place_9","text":"Il faut que les 2 Raspberry Pi soit en mode \"D\u00e9couvrable\" activable ici : . Il faut ensuite effectuer un scan des appareils si nous ne connaissons pas le nom d'h\u00f4te de l'autre Raspberry Pi. Le script doit \u00eatre pr\u00e9sent sur les deux Raspberry Pi afin de pouvoir \u00e9couter, recevoir ainsi qu'envoyer des messages. La machine h\u00f4te, moi dans ce contexte, doit \u00eatre en mode MODE_SEND tandis que l'autre en mode MODE_RECEIVE.","title":"Mise en place"},{"location":"documentation_technique/#utilisation_9","text":"Le code fonctionne de la mani\u00e8re suivante. La machine h\u00f4te va en premier temps lancer le scan \u00e0 la recherche de l'appareil nomm\u00e9 morenoPi42 . Une fois l'appareil trouv\u00e9, je m'y appareille, puis lui envoie le premier message. Le mode actuel, change et je deviens la machine qui \u00e9coute le port sp\u00e9cifi\u00e9 en attendant un message.","title":"Utilisation"},{"location":"documentation_technique/#dates-importantes","text":"Lundi 19 avril 2021 : D\u00e9but du travail de dipl\u00f4me Vendredi 30 avril 2021 : \u00c9valuation interm\u00e9diaire 1 Vendredi 14 mai 2021 : Rendu du rapport interm\u00e9diaire + poster Vendredi 14 mai 2021 : Rendu version interm\u00e9diaire du r\u00e9sum\u00e9 et de l\u2019abstract (pour conseils par l\u2019enseignant d\u2019anglais) Lundi 17 mai 2021 : \u00c9valuation interm\u00e9diaire 2 Jeudi 20 mai 2021 apr\u00e8s-midi : Soir\u00e9e poster : amis, famille, CFC, experts 14h00 : Visite des classes de 1re ann\u00e9e (cf. SG) 16h30 : Amis, famille, experts, enseignants Tech ES\u2026 18h00 : Fin de la soir\u00e9e poster Lundi 31 mai 2021 : \u00c9valuation interm\u00e9diaire 3 Vendredi 11 juin 2021 : Rendu du travail avant 12h00 Jeudi 17 juin 2021 : D\u00e9fenses \u00e0 blanc + harmonisation des notes Lundi 21 juin ou mardi 22 juin 2021 : D\u00e9fenses de dipl\u00f4me","title":"Dates importantes"},{"location":"documentation_technique/#retour-dexperience","text":"","title":"Retour d'exp\u00e9rience"},{"location":"documentation_technique/#problemes-rencontres","text":"","title":"Probl\u00e8mes rencontr\u00e9s"},{"location":"documentation_technique/#resultat","text":"","title":"R\u00e9sultat"},{"location":"documentation_technique/#ce-quil-reste-a-faire","text":"","title":"Ce qu'il reste \u00e0 faire"},{"location":"documentation_technique/#ameliorations-possibles","text":"","title":"Am\u00e9liorations possibles"},{"location":"documentation_technique/#bilan-personnel","text":"","title":"Bilan personnel"},{"location":"documentation_technique/#apports-personnels","text":"","title":"Apports personnels"},{"location":"documentation_technique/#conclusion","text":"","title":"Conclusion"},{"location":"documentation_technique/#journal-de-bord","text":"","title":"Journal de bord"},{"location":"documentation_technique/#glossaire","text":"","title":"Glossaire"},{"location":"documentation_technique/#code-source","text":"","title":"Code source"},{"location":"logbook/","text":"Journal de bord du travail de dipl\u00f4me 2021 19.04.2021 J'ai copi\u00e9 le disque dur de M. Bauduccio car le mien causait des soucis M. Moreno, M. Huber et moi avons eu un entretien avec M. Bonvin pour discuter des appr\u00e9ciations du stage J'ai mis en place mon poste (Cr\u00e9ation du repository, installation des programmes n\u00e9cessaires tel que : VS Code, Github Desktop, Suite Office, etc...) J'ai lu le chapitre 6 du magpi nomm\u00e9 \"Le guide officiel du d\u00e9butant Raspberry Pi\" conseill\u00e9 par M. Bonvin J'ai commenc\u00e9 \u00e0 m'int\u00e9resser \u00e0 l'utilisation du Remote GPIO pour \u00e9tablir une connexion entre mon Raspberry Pi 4 et celui de M. Moreno Nous avons d'abord mis nos 2 Raspberry Pi sur le m\u00eame r\u00e9seau, ensuite nous nous sommes assur\u00e9s que l'interface Remote GPIO \u00e9tait bien active des 2 c\u00f4t\u00e9s et nous avons v\u00e9rifi\u00e9 que pigpio \u00e9tait bien install\u00e9, puis pour terminer nous avons mis en place le code disponible dans ce PDF \u00e0 la page 61 sur le Raspberry Pi de M. Moreno. Avant d'ex\u00e9cuter le programme, nous avons tout deux ex\u00e9cuter la commande suivante dans un terminal sudo pigpiod De son c\u00f4t\u00e9 nous avons utilis\u00e9 un bouton pressoir et du miens une LED Le bouton est connect\u00e9 au GPIO 2, donc la pin 3 La led est connect\u00e9e au GPIO 17, donc la pin 11 Le code disponible sur la machine de M. Moreno va attendre que le bouton soit press\u00e9, une fois ceci fait, la LED connect\u00e9 en remote (li\u00e9e \u00e0 mon Raspberry Pi) se vera allum\u00e9e. J'ai commenc\u00e9 mes recherches sur l'\u00e9change d'informations par bluetooth entre 2 Raspberry Pi 4 J'ai tent\u00e9 de mettre en place le code disponible sur ce repos mais j'avais l'erreur suivante ModuleNotFoundError: No module named 'bluetooth' , pourtant j'avais d\u00e9j\u00e0 le bluetooth d'install\u00e9 ainsi que blueman. En faisant des recherches je suis tomb\u00e9 sur cette commande sudo apt-get install bluetooth libbluetooth-dev && sudo python3 -m pip install pybluez . Depuis l'installation des 2 commandes je n'ai plus d'erreurs d'import. Liens consult\u00e9s Remote GPIO https://www.instructables.com/Remote-control-Raspberry-PI-GPIO-pins-over-the-int/ https://www.instructables.com/Raspberry-Pi-Remote-GPIO/ https://magpi.raspberrypi.org/articles/remote-control-gpio-raspberry-pi-gpio-zero https://magpi.raspberrypi.org/issues/60 \u00c9change d'informations par bluetooth entre 2 Raspberry Pi 4 https://technologisttips.com/raspberry-pi-bluetooth/ https://bluedot.readthedocs.io/en/latest/pairpipi.html https://gist.github.com/keithweaver/3d5dbf38074cee4250c7d9807510c7c3 https://www.stuffaboutcode.com/2017/07/python-bluetooth-rfcomm-client-server.html https://bluedot.readthedocs.io/en/latest/pairpipi.html https://stackoverflow.com/questions/23985163/python3-error-no-module-named-bluetooth-on-linux-mint#23985374 20.04.2021 M. Moreno et moi avons continu\u00e9 l'\u00e9change d'informations par bluetooth entre nos 2 Raspberry Pi 4 De mon c\u00f4t\u00e9, j'ai utilis\u00e9 les fonctions suivantes : lookUpNearbyBluetoothDevices , va lancer un scan bluetooth pour d\u00e9couvrir les appareils alentours. Pour chaque appareil trouv\u00e9s, ils vont \u00eatre affich\u00e9s dans la console, si l'un de ces appareils est nomm\u00e9 morenoPi42 alors son adresse mac se voit \u00eatre retourn\u00e9e pour \u00eatre utilis\u00e9e en param\u00e8tre par la fonction ci-dessous. sendMessageTo va se connecter \u00e0 un appareil \u00e0 l'aide de son adresse mac et d'un port d\u00e9sign\u00e9 (le port 1 dans notre cas) pour ensuite lui envoy\u00e9 une information et fermner la connexion. Du c\u00f4t\u00e9 de M. Moreno, il a utilis\u00e9 la m\u00e9thode receiveMessage qui va \u00e9couter sur le port sp\u00e9cifi\u00e9 (dans notre cas, il s'agit toujours du port 1), qui va ensuite accepter la connexion entrante jusqu'\u00e0 1024 bytes, puis affiche dans la console les donn\u00e9es re\u00e7ues, une fois cela fait, elle va fermer les sockets de connexion. Avec M. Moreno, nous avons modifi\u00e9 le programme pour en faire un t'chat par bluetooth. Pour lancer le programme, il faut utiliser la commande suivante en rempla\u00e7ant le XXXX par le nom d'h\u00f4te de l'appareil bluetooth : python3 bluetooth_data_transfer.py XXXX En premier temps nous avons pens\u00e9 regrouper l'ouverture des sockets dans une fonction d'initialisation afin d'avoir une trace sur les sockets pour pouvoir les fermer lorsque cela est voulu. Nous avons une erreur nous indiquant ceci _bluetooth.error: (111, 'Connection refused') , cela nous a fait comprendre que pour s'envoyer des informations, il faut que l'un \u00e9coute pendant que l'autre parle et r\u00e9ciproquement dans l'autre sens. Nous avons mis en place une boucle while qui tourne constamment. Dans cette boucle, il y a des if qui v\u00e9rifient le mode actuel. 0 veut dire que nous sommes en attente d'un message 1 veut dire que nous allons envoy\u00e9 un message 1. Affiche le nom d'h\u00f4te et l'adresse mac de l'appareil connect\u00e9 2. Espace de saisie de message \u00e0 envoyer 3. Connexion r\u00e9ussie \u00e0 l'appareil (adresse mac, port) 4. R\u00e9ception du message 5. Espace de saisie de message \u00e0 envoyer, utilisant une commande personnalis\u00e9e pour quitter le programme J'ai commenc\u00e9 mes recherches sur le Technic Hub . Liens consult\u00e9s \u00c9change d'informations par bluetooth entre 2 Raspberry Pi 4 https://pybluez.readthedocs.io/en/latest/api/bluetooth_socket.html Sockets https://docs.python.org/3/library/socket.html R\u00e9cup\u00e9ration de saisie utilisateur https://pythonprogramminglanguage.com/user-input-python/ R\u00e9cup\u00e9ration de param\u00e8tres en ligne de commande Python https://www.pythonforbeginners.com/system/python-sys-argv Bluetooth LEGO https://lego.github.io/lego-ble-wireless-protocol-docs/ https://github.com/hoharald/leguno-remote 21.04.2021 J'ai commenc\u00e9 la journ\u00e9e par lire cet article sur le bluetooth pour tenter d'approfondir mes connaissances afin de r\u00e9gler le probl\u00e8me de connexion entre le Raspberry Pi et le Technic Hub . Apr\u00e8s avoir lu l'article, j'ai tent\u00e9 de relancer le code d'exemple disponible sur le repos Bricknil , malheureusement j'avais toujours la m\u00eame erreur. Je me suis dit que j'allais tent\u00e9 de cr\u00e9er un script python qui ne fait que se connecter pour l'instant pour pouvoir ensuite tent\u00e9 d'envoyer des ordres par bluetooth. J'ai commenc\u00e9 par essayer de lire dans cette documentation et de comprendre comment je pouvais envoyer des messages que le Technic Hub pourrait comprendre. J'ai donc en un premier temps cherch\u00e9 \u00e0 comprendre si c'\u00e9tait \u00e0 moi d'envoy\u00e9 le premier message et sur quel port ou de faire l'inverse, c'est-\u00e0-dire moi \u00e9couter un port particulier car \u00e0 chaque fois que depuis l'interface graphique ou par commande dans le terminal, quand je tente de me connecter au Technic Hub , j'ai toujours cette erreur ci : Failed to pair: org.bluez.Error.AuthenticationFailed . La premi\u00e8re chose que j'ai constat\u00e9, c'est que des fois apr\u00e8s avoir beaucoup tent\u00e9 d'utiliser le bluetooth de red\u00e9marrer le Raspberry Pi car il a de la peine \u00e0 capter les appareils alentours, tandis qu'une fois red\u00e9marr\u00e9, si l'on utilise bluetoothctl , qu'on active le scan avec scan on , on peut voir les informations suivantes : [NEW] Device 90:84:2B:50:36:43 Technic Hub [CHG] Device 90:84:2B:50:36:43 RSSI: -58 [CHG] Device 90:84:2B:50:36:43 TxPower: 0 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: 00 80 06 00 61 00 ....a. RSSI (Received Signal Strength Indicator) repr\u00e9sente la mesure du niveau de la puissance au niveau du r\u00e9cepteur. Il est mesur\u00e9 en dBm, sur une \u00e9chelle logarithmique et \u00e9tant n\u00e9gatif. Plus le nombre est n\u00e9gatif, plus le dispositif est \u00e9loign\u00e9. Par exemple, une valeur de -20 \u00e0 -30 dBm indique que le dispositif est proche, tandis qu'une valeur de -120 indique que le dispositif est proche de la limite de d\u00e9tection. TxPower repr\u00e9sente la puissance du signal. Pour un \u00e9metteur Bluetooth, 0 dBm (d\u00e9cibel-milliwatt) est le niveau de puissance standard ManufacturerData Key: 0x0397 est le code de LEGO System A/S ManufacturerData Value: 00 80 06 00 61 00 Longueur des donn\u00e9es (0x09) Le nom du type de donn\u00e9es (0xFF) L'ID du fabricant (0x0397) L'\u00e9tat du bouton (entre 0x00 et 0x01) Le type de syst\u00e8me et le num\u00e9ro de l'appareil (entre 0x00 et 0xFF) Les capacit\u00e9s de l'appareil (entre 0x01 et 0xFF) L'id du pr\u00e9c\u00e9dent r\u00e9seau (entre 0x00 et 0xFF) Le statut actuel (entre 0x00 et 0xFF) En continuant mes recherches, je me suis demand\u00e9 s'il n'\u00e9tait pas une bonne id\u00e9e de tester petit \u00e0 petit ce que propose le code de Bricknil pour ensuite l'impl\u00e9ment\u00e9 petit \u00e0 petit. Le premier \u00e9l\u00e9ment que je voulais tester \u00e9tait le bleak car j'avais vu lorsque je lan\u00e7ais le code de Bricknil qu'il y avait un message contenant le nom de ce module. Pour installer bleak , pygatt et bluepy j'ai utilis\u00e9 cette commande : sudo pip3 install pygatt && pip3 install gatt && pip3 install gattlib && pip3 install bluepy && pip3 install bleak . Une fois cela fait, j'ai donc \u00e9t\u00e9 sur le repos officiel pour ex\u00e9cuter le code pr\u00e9sent. Le premier code nous montre la m\u00e9thode discover tandis que le second nous montre une mani\u00e8re de s'appareiller. La premi\u00e8re chose que j'ai faite c'est de tester la connexion. Pour ce faire, j'ai test\u00e9 la m\u00e9thode discover disponible gr\u00e2ce \u00e0 BleakScanner . J'ai pu voir appara\u00eetre le Technic Hub dans la liste des appareils d\u00e9tect\u00e9s. Pour tenter de me \"connecter\", j'ai utilis\u00e9 l'adresse mac tel que : 90:84:2B:50:36:43 ainsi que le Characteristic UUID tel que : 00001624-1212-EFDE-1623-785FEABCD123 qui va ensuite retourner le num\u00e9ro de mod\u00e8le. La led sur le Technic Hub devient bleue lorsque je lance le programme et que la m\u00e9thode read_gatt_char est ex\u00e9cut\u00e9e. Cette m\u00e9thode retourne un array de byte, dans mon cas voici ce qu'elle me retourne \\x05\\x00\\x04\\x03\\x00.\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00 , autrement \u00e9crit : 50430460016000160000000 . Liens consult\u00e9s Bluetooth https://www.novelbits.io/deep-dive-ble-packets-events/ https://punchthrough.com/crash-course-in-2m-bluetooth-low-energy-phy/ https://github.com/karulis/pybluez https://www.bluetoothle.wiki/tx_power https://www.bluetoothle.wiki/rssi?s[]=rssi https://www.bluetooth.com/specifications/assigned-numbers/company-identifiers/ https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://bleak.readthedocs.io/en/latest/usage.html https://github.com/hbldh/bleak https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt Repos Bricknil https://github.com/virantha/bricknil Date avec python https://www.tutorialspoint.com/How-to-print-current-date-and-time-using-Python 22.04.2021 J'ai continu\u00e9 mon travail sur le bluetooth. Histoire d'y voir un peu plus claire je me suis r\u00e9sign\u00e9 \u00e0 faire un sch\u00e9ma explicant + en d\u00e9tails quelles sont les valeurs que nous avons re\u00e7u et qu'est-ce qu'elles veulent dire \u00e0 l'aide de la documentation de Lego pour le Bluetooth . J'ai remarqu\u00e9 un potentiel probl\u00e8me. Soit c'\u00e9tait moi qui n'arrivait pas \u00e0 comprendre comment le tableau des Manufacturer Data \u00e9tait con\u00e7u ou si juste les donn\u00e9es re\u00e7us par le bluetooth lors du scan de l'appareil \u00e9taient incompl\u00e8tes. Comme on peut le voir ci-dessous, je n'ai pas pris en compte l'ID du fabricant car comme vu ici : [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 , il a ne semble pas avoir de champ pour lui dans le [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: . J'ai tent\u00e9 de rentrer les informations suivantes : 00 80 06 00 61 00 en prenant compte de la taille min et max de chaque cellules (voir la documentation de Lego pour le Bluetooth ) pour calculer la longueur de la trame, j'ai ensuite v\u00e9rifi\u00e9 que les donn\u00e9es puissent rentrer dans les champs et c'est \u00e0 ce moment que j'ai commenc\u00e9 \u00e0 me demander si quelque chose ne jouait pas. En effectuant des recherches, je suis tomb\u00e9 sur cet article . Il parlait d'une application smarthphone nomm\u00e9e EFR Connect . J'en avais besoin car je voulais avoir plus d'informations concernant les Manufacturer Data . J'ai lanc\u00e9 un scan depuis l'application, et en ce qui concerne voici les informations que l'application m'a retroun\u00e9e : Flags : 0x06: LE General Discoverable Mode, BR/EDR Not Supported Complete list of 128-bit service class UUIDs : 00001624-1212-EFDE-1623-785FEABCD123 Manufacturer Data : Company Code : 0x0397 Data : 0x008006004100 Slave connection interval range : 20.0ms Tx power level: 0 dBm Complete local name : Technic Hub Je me suis ensuite connect\u00e9 au Technic Hub avec l'application, j'ai vu appara\u00eetre un sous menu m'affichant 3 sections : Generic attribute : 0x1801 UUID : 0x2A05 Descriptor : champs vide Client characteristic configuration : 0x2902 Generic access : Device name : 0x1800 Appearance : 0x2A01 Peripheral preffered connection parameters : 0x2A04 Unknown Service : UUID : 00001624-1212-EFDE-1623-785FEABCD123 Descriptor : champs vide Client characteristic configuration : 0x2902 Value : 50430460016000160000000 mais lorsque depuis l'application j'active le mode notify sa valeur change \u00e0 0F 04 64 01 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 En voyant ces donn\u00e9es je me suis dit que j'avais pris les mauvaises donn\u00e9es \u00e0 mettre dans le tableau des Manufacturer Data. J'ai abandonn\u00e9 l'id\u00e9e de remplir le tableau de Manufacturer Data car ces donn\u00e9es ne correspondaient pas. En revanche, j'ai tent\u00e9 de jouer avec l'application EFR Connect car on peut lire, \u00e9crire et \u00eatre notifi\u00e9. Lorsque je me connecte au Technic Hub et que je lit les donn\u00e9es pr\u00e9sentes voici ce que je re\u00e7ois : 0F 04 64 01 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 . J'ai ensuite essayer d'envoyer la commande Hub Properties car on peut envoyer de l'hexad\u00e9cimal au hub, j'ai donc tent\u00e9 avec les valeurs du tableau ici pr\u00e9sent . Ensuite, avec le mode \u00e9criture lorsque j'ai relus le contenu avec chang\u00e9 et \u00e9tait devenu : 05 00 05 00 05 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 . En me balandant sur internet je suis retomb\u00e9 sur ce lien qui disait que le Technich Hub peut uniquement \u00eatre programm\u00e9 avec le firmware de PyBricks. J'ai donc essay\u00e9 de t\u00e9l\u00e9charger le repos git et d'installer le firmware \"manuellement\" afin de pouvoir \u00e9crire mes propres script python pour contr\u00f4ler la voiture. J'ai suivi le tutoriel de mise en place pour un environnement de d\u00e9veloppement mais je n'ai r\u00e9ussi \u00e0 le mettre en place. Je suis ensuite tomb\u00e9 sur cette issue git qui met \u00e0 disposition des fichier de firmware pour les hub Spike et Mindstorm . J'ai ensuite retent\u00e9 de comprendre comment lire la documentation de Lego . Liens consult\u00e9s Bluetooth https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://stackoverflow.com/questions/52352378/manufacturer-specific-data-on-ble https://docs.silabs.com/bluetooth/2.13/code-examples/stack-features/adv-and-scanning/adv-manufacturer-specific-data https://brickarchitect.com/powered-up/#footnote1 https://github.com/pybricks/pybricks-micropython https://github.com/pybricks/support/issues/167 https://github.com/pybricks/pybricksdev 23.04.2021 J'ai commenc\u00e9 la journ\u00e9e par lire cette documentation pour mieux comprendre ce qu'est GATT et comment il est structur\u00e9, pour pouvoir l'utiliser ensuite. Les attributs GATT sont des \u00e9l\u00e9ments d'information adressables qui peuvent contenir des donn\u00e9es utilisateur pertinentes (ou m\u00e9tadonn\u00e9es) sur la structure et le regroupement des diff\u00e9rents attributs contenus dans le serveur. Gatt est structur\u00e9 de la mani\u00e8re suivante : Roles Client Server UUID Attributes Handle : 0x0000 = d\u00e9note un handle invalde, le montant d'handle dipsonible sur chaque serveur GATT est 0xFFFF (soit 16 bits, 65535) Type : d\u00e9termine le type de donn\u00e9e des valeurs de l'attribut, il s'agit d'un UUID Permissions Access permissions : similaire au droit li\u00e9 aux fichiers (None, Readable, Writable, Readable & Writable) Encryption : Security mode 1, level 1 Attribut accessible en texte, connexion non encrypt\u00e9e Security mode 1, level 2 La connexion doit \u00eatre encrypt\u00e9e pour avoir acc\u00e8s \u00e0 l'attribut, mais les cl\u00e9s d'encryptions non pas besoin d'\u00eatre authentifi\u00e9es Security mode 1, level 3 La connexion doit \u00eatre encrypt\u00e9e avec des cl\u00e9s authentifi\u00e9es pour avois acc\u00e8s \u00e0 l'attribut. Autorization : d\u00e9termine si une permission utilisateur est n\u00e9cessaire Value : Contient les donn\u00e9es de l'attribut, il n'y a pas de restrictions pour le type de donn\u00e9es qu'il contient mais jusqu'\u00e0 une limite de 512 bytes Attribute and data hierarchy GATT Server : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown service) Characteristic : Unknown Charateristic Les attributs sont group\u00e9s en services , chaque services peut contenir 0 ou + characteristics . Ces derni\u00e8res peuvent avoir de 0 \u00e0 + descriptors Advanced attribute concepts Features Security GATT service J'ai install\u00e9 gatt \u00e0 l'aide de la commande sudo pip3 install gatt . Ensuite j'ai scann\u00e9 les alentours avec la commande sudo gattctl --discover . Une fois que j'ai vu appara\u00eetre le Technic Hub je m'y suis connect\u00e9 \u00e0 l'aide de sudo gattctl --connect 90:84:2B:50:36:43 . On peut voir que les donn\u00e9es re\u00e7ues sont bien celles pr\u00e9sentes dans l'application EFR Connect : Connecting... [90:84:2b:50:36:43] Discovered, alias = Technic Hub [90:84:2b:50:36:43] Connected [90:84:2b:50:36:43] Discovered, alias = Technic Hub [90:84:2b:50:36:43] Resolved services [90:84:2b:50:36:43] Service [00001623-1212-efde-1623-785feabcd123] [90:84:2b:50:36:43] Characteristic [00001624-1212-efde-1623-785feabcd123] [90:84:2b:50:36:43] Service [00001801-0000-1000-8000-00805f9b34fb] [90:84:2b:50:36:43] Characteristic [00002a05-0000-1000-8000-00805f9b34fb] M. Bonvin m'a montr\u00e9 comment utiliser QCad , c'est un outil de dessin technique assit\u00e9. Je me suis ensuite remis sur la documentation pour comprendre comment cela marchait. J'ai ex\u00e9cuter le second code pr\u00e9sent sur le repos mais cette erreur m'est apparue : ERROR:dbus.connection:Exception in handler for D-Bus signal: Traceback (most recent call last): File \"/usr/local/lib/python3.7/dist-packages/dbus/connection.py\", line 232, in maybe_handle_message self._handler(*args, **kwargs) File \"/home/pi/.local/lib/python3.7/site-packages/gatt/gatt_linux.py\", line 398, in properties_changed self.services_resolved() File \"gatt_connection.py\", line 10, in services_resolved s for s in self.services StopIteration J'ai \u00e9t\u00e9 voir sur internet ce que l'erreur ERROR:dbus.connection:Exception in handler for D-Bus signal voulait signifier. Je n'ai pas r\u00e9ussis \u00e0 trouver d'informations pertinentes, donc je me suis remis sur le script python utilisant GATT. J'ai tent\u00e9 de modifier le second code afin d'\u00eatre s\u00fbr qu'il fonctionnait. Il semble donc que l'erreur vienne du second script. J'ai cherch\u00e9 ce quel \u00e9l\u00e9ment pose probl\u00e8me mais je peine encore \u00e0 trouver le probl\u00e8me. Liens consult\u00e9s Bluetooth http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gatt.html https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch04.html https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch02.html#Protocol_Stack https://doc.qt.io/qt-5/qtbluetooth-le-overview.html https://github.com/getsenic/gatt-python 26.04.2021 Liens consult\u00e9s Pour commencer la semaine, je me suis dit que regarder des vid\u00e9os explicative sur le fonctionnement de GATT et du bluetooth en g\u00e9n\u00e9ral, car ayant pass\u00e9 la semaine pass\u00e9e sur de la documentation explicative sur GATT mais qui ne m'avait pas aid\u00e9 \u00e0 r\u00e9soudre les soucis que j'avais. Comme pour le 23.04.2021, je vais tenter de refaire une explication d\u00e9taill\u00e9e du fonctionnement de GAP et GATT car \u00e7a me permettera de l'inclure plus ais\u00e9ment dans la documentation que je n'ai toujours pas commenc\u00e9e \u00e0 l'heure actuelle, mais je me suis dit qu'aujourd'hui devait \u00eatre le dernier d\u00e9lai pour conclure cette histoire de bluetooth car il faut que je me concentre sur la documentation technique sachant qu'elle sera \u00e9valu\u00e9e le 30.04.2021. GAP , Generic Access Profile , contr\u00f4le les connexions ainsi que l'avertissement d\u00e9terminant comment les 2 appareils vont pouvoir ou pas int\u00e9ragir. GATT , Generic Attribute Profile ,d\u00e9finit comment les 2 appareils vont \u00e9changer des donn\u00e9es compos\u00e9es de Services et de Characteristics . Ce protocole int\u00e9rvient uniquement une fois le GAP pass\u00e9. J'ai repris la structure que j'avais faite pour montrer la structure du Technic Hub au niveau GATT : Profile : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown service) Characteristic : Unknown Charateristic Comme on peut le voir, Profile contient une collection de services. Ces derniers divisent les donn\u00e9es en entit\u00e9s logiques qui contiennent des blocs de donn\u00e9es sp\u00e9cifiques appel\u00e9s caract\u00e9ristiques. Ce sont ces caract\u00e9ristiques qui contiennent les donn\u00e9es importantes. Depuis l'application mobile EFR Connect , j'ai tent\u00e9 dans la characteristic concernant le Technic Hub d'\u00e9crire des commandes de la mani\u00e8re suivante : Dans la documentation lego les commandes sont dans un chapitre Output Command 0x81 . Dans ce chapitre, les commandes pr\u00e9sentent sont \u00e9crites comme suit StartPower (Power1, Power2): Output Command 0x81 - Sub Command 0x02 . \u00c9tant donn\u00e9 qu'il s'agit de sub command , je ne sais pas si \u00e9crire en hexa une suite de bytes en hexa permet d'ex\u00e9cuter une commande. En tout cas, depuis que j'ai tent\u00e9 d'\u00e9crire une commande, lorsque j'ai activ\u00e9 le mode notify la valeur retourn\u00e9e est la suivante 0F 00 04 61 01 39 00 01 00 00 00 01 00 00 00 . Je sais que je change de cap souvent, mais \u00e9tant un peu perdu je tente d'explorer chaques id\u00e9es qui me vient en t\u00eate. Celle que je viens d'avoir concerne l'utilisation du code pr\u00e9sent sur le repos de pyboost , car m\u00eame s'il concerne le LEGO Boost Move Hub je me suis dit qu'il y a moyen que puisse l'utiliser. De plus sur la documentation de Lego Wireless Protocol il parlait de SDK, je me suis dit qu'il fallait que je trouve un bon SDK et je suis alors tomb\u00e9 en premier temps sur celle de pyb00st . Par cons\u00e9quent, j'ai clon\u00e9 le repos sur le Raspberry Pi afin d'ex\u00e9cuter les codes d'exemples. J'ai commenc\u00e9 par utiliser la m\u00e9thode set_led_color(color) pour voir si la connexion et les m\u00e9thodes int\u00e9ragissaient avec le Technic Hub . R\u00e9sultat, \u00e7a fonctionne. Maintenant je vais m'int\u00e9resser aux m\u00e9thodes touchant aux moteurs. je n'ai pas r\u00e9ussi \u00e0 impl\u00e9menter pyb00st , cependant je me suis dit que d'utiliser le code de pylgbst pourrait fonctionner car j'ai \u00e9t\u00e9 lire la documentation Lego , et vu qu'elle parle de commandes \u00e0 envoy\u00e9, j'ai \u00e9t\u00e9 voir s'il en proposait. Apr\u00e8s quelque recherche, j'ai vu que oui. M\u00eame si rien n'\u00e9tait \u00e9cris \u00e0 propos du Technic Hub , je me suis lanc\u00e9 en me disant que \u00e7a doit \u00eatre exactement le m\u00eame m\u00e9canisme. J'ai commenc\u00e9 par utiliser la m\u00e9thode get_connection_auto() , cette fonction va choisir parmi la liste suivante : bluepy bluegiga gatt bleak gattool gattlib \u00c0 noter qu'on peut choisir par nous m\u00eame quel type de connexion nous voulons \u00e9tablir en reprennant get_connection_auto() mais en repla\u00e7ant le auto par l'un des moyens disponible ci-dessus. M'\u00e9tant document\u00e9 ces dernier jours sur GATT et ayant utilis\u00e9 un code fonctionnel, je suis partit du postulat que \u00e7a devrait fonctionn\u00e9 sans soucis. J'ai donc commenc\u00e9 par utiliser la m\u00e9thode get_connection_gatt() en lui sp\u00e9cifiant l'adresse mac de l'appareil comme suit : get_connection_gatt(hub_mac=\"90:84:2B:50:36:43\") . La m\u00e9thode affiche ceci dans la console : Have not dedicated class for peripheral type 0x2f on port 0x0 Have not dedicated class for peripheral type 0x2f on port 0x1 Have not dedicated class for peripheral type 0x2e on port 0x2 Have not dedicated class for peripheral type 0x3c on port 0x3d Have not dedicated class for peripheral type 0x3c on port 0x60 Have not dedicated class for peripheral type 0x39 on port 0x61 Have not dedicated class for peripheral type 0x3a on port 0x62 Have not dedicated class for peripheral type 0x3b on port 0x63 Have not dedicated class for peripheral type 0x36 on port 0x64 Got only these devices: (Peripheral on port 0x0, Peripheral on port 0x1, None, LEDRGB on port 0x32, None, Current on port 0x3b, Voltage on port 0x3c) Une fois ceci affich\u00e9, j'ai cr\u00fb comprendre que la connexion \u00e9tait bien \u00e9tablie et que des commandes pouvait \u00eatre envoy\u00e9es. J'ai regard\u00e9 dans les fichiers peripherals et hub fournis par pylgbst comment \u00e9tait structur\u00e9 la classe moteur et quels fonctions \u00e9taient disponibles. Apr\u00e8s avoir compris, j'ai \u00e9crit ce bout de code : from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor from pylgbst import * MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) motor_a = Motor(movehub, movehub.PORT_A) motor_c = Motor(movehub, movehub.PORT_C) motor_a.start_power(-1) motor_c.start_power(1) conn.disconnect() finally: conn.disconnect() Ce bout de code fonctionne parfaitement. Entre temps j'ai \u00e9cris celui ci qui fonctionne parfaitement lui aussi : #!/usr/bin/env python3 from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor from pylgbst import * from time import sleep MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" def play_scenario(movehub): motor_a = Motor(movehub, movehub.PORT_A) motor_b = Motor(movehub, movehub.PORT_B) motor_c = EncodedMotor(movehub, movehub.PORT_C) print(\"Forward:\") forward(motor_a, motor_b, motor_c) sleep(1) print(\"Downward:\") downward(motor_a, motor_b, motor_c) sleep(1) print(\"Left:\") go_left(motor_a, motor_b, motor_c) sleep(1) print(\"Right:\") go_right(motor_a, motor_b, motor_c) sleep(1) def forward(motor_1, motor_2, motor_3): motor_1.start_power(-1) motor_2.start_power(-1) motor_3.start_power(0) print(\"done!\") def downward(motor_1, motor_2, motor_3): motor_1.start_power(1) motor_2.start_power(1) motor_3.start_power(0) print(\"done!\") def go_left(motor_1, motor_2, motor_3): motor_1.start_power(0) motor_2.start_power(0) motor_3.start_power(-1) print(\"done!\") def go_right(motor_1, motor_2, motor_3): motor_1.start_power(0) motor_2.start_power(0) motor_3.start_power(1) print(\"done!\") conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) play_scenario(movehub) conn.disconnect() finally: conn.disconnect() Cependant de temps en temps quand je relance le programme. Cette erreur appara\u00eet : Traceback (most recent call last): File \"pylgbst_bluetooth.py\", line 53, in <module> conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) File \"/usr/local/lib/python3.7/dist-packages/pylgbst/__init__.py\", line 25, in get_connection_gatt return GattConnection(controller).connect(hub_mac, hub_name) File \"/usr/local/lib/python3.7/dist-packages/pylgbst/comms/cgatt.py\", line 100, in connect for dev in devices: RuntimeError: dictionary changed size during iteration Pour la r\u00e9soudre, en g\u00e9n\u00e9ral, j'\u00e9teins le bluetooth puis je le rallume et cela semble r\u00e9soudre le probl\u00e8me de temps en temps. De temps \u00e0 autre cette technique ne fonctionne pas et je dois red\u00e9marrer le Raspberry Pi afin de r\u00e9gler le probl\u00e8me. J'ai essay\u00e9 pendant un long moment \u00e0 mettre en place un syst\u00e8me qui permetterai de reset l'angle du moteur g\u00e9rant la direction. Le probl\u00e8me que j'ai est que je n'ai pas r\u00e9ussi \u00e0 trouver les valeurs minimals et maximales pour les angles, car lorsque l'on dit au moteur d'utiliser la fonction angled(degrees=-150) suivi de angled(degrees=75) , ce qui devrait mettre le moteur tout \u00e0 droite puis au centre mais le probl\u00e8me est qu'apr\u00e8s la premi\u00e8re instruction, l'ex\u00e9cution s'arr\u00eate. Est-ce que la premi\u00e8re valeur fait crash le programme ? Ayant pratiquement termin\u00e9 avec le bluetooth, je me suis dit que je devais commencer la documentation technique car pour l'heure rien n'avait \u00e9t\u00e9 fait \u00e0 ce sujet. Bluetooth Youtube https://www.youtube.com/watch?v=u4HY3OIk2-c https://www.youtube.com/watch?v=MzM3-YWftxE https://www.youtube.com/watch?v=E8_5UZWDgMo https://www.youtube.com/watch?v=eHqtiCMe4NA Bluetooth http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gatt.html#gatt-characteristics-and-attributes https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch04.html#gatt_attr_table https://devzone.nordicsemi.com/f/nordic-q-a/6700/adding-characteristic-user-description-0x2901-0x2902 https://github.com/getsenic/gatt-python https://bleak.readthedocs.io/en/latest/usage.html https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://github.com/peplin/pygatt https://github.com/JorgePe/pyb00st https://github.com/undera/pylgbst 27.04.2021 J'ai d\u00e9but\u00e9 la journ\u00e9e en continuant le documentation technique. Durant l'apr\u00e8s-midi, avec M. Ray Yvelin, M. Bonvin et moi m\u00eame, nous sommes aller apporter du mat\u00e9riel en C305 \u00e0 Ternier et nous avons pris dans cette salle : 1 Oscilloscope 1 Alimentation stabilis\u00e9e Les c\u00e2bles associ\u00e9s au \u00e9l\u00e9ments ci-dessus Des tournevis 1 Fer \u00e0 souder avec de la soudure 1 Multim\u00e8tre 1 \u00c9taux Apr\u00e8s cela j'ai continu\u00e9 \u00e0 travailler sur la documentation technique. Liens consult\u00e9s Donn\u00e9es relatives au capteurs https://pijaeducation.com/arduino/sensor/ir-sensor-and-arduino/ https://fr.wikipedia.org/wiki/Baud_(mesure) https://fr.wikipedia.org/wiki/UART http://bucket.download.slamtec.com/20b2e974dd7c381e46c78db374772e31ea74370d/LD208_SLAMTEC_rplidar_datasheet_A2M8_v2.6_en.pdf https://en.wikipedia.org/wiki/Pulse-width_modulation https://github.com/Slamtec/rplidar_sdk/releases/tag/release%2Fv1.12.0 28.04.2021 J'ai continu\u00e9 la documentation technique. Apr\u00e8s l'entretien avec M. Bonvin, j'ai mis \u00e0 disposition le code \u00e9crit sur le Raspberry Pi, puis je me suis remis \u00e0 travailler sur la documentation technique. Pour expliquer plus en d\u00e9tails les composants qui composeront le voiture, j'ai r\u00e9alis\u00e9 ce croquis : J'ai tent\u00e9 d'importer l'\u00e9tat actuel de ma documentation technique sur ReadTheDoc, mais la version en ligne qui cr\u00e9ait une documentation \u00e0 partir d'un repository Github ne fonctionnait pas vraiment. J'ai alors install\u00e9 MkDocs pour g\u00e9n\u00e9rer la documentation \u00e0 partir du fichier Markdown. Liens consult\u00e9s Flask https://flask.palletsprojects.com/en/1.1.x/quickstart/ MkDocs https://www.mkdocs.org/#installation 29.04.2021 J'ai commenc\u00e9 par d\u00e9finir plus clairement ce qu'\u00e9tait le bluetooth dans la documentation technique. J'ai recompil\u00e9 la documentation technique avec MkDocs pour avoir un aper\u00e7u de la mise en forme. J'ai eu des soucis de mise en page en ce qui concerne les listes \u00e0 points ou num\u00e9rot\u00e9es tandis qu'affiche en Markdown fonctionnent tr\u00e8s bien. Pour ne pas perdre plus de temps dessus j'ai comment\u00e9 tous le code \u00e9crit. Apr\u00e8s avoir tous comment\u00e9, je me suis remis sur la documentation afin d'expliquer le T'chat bluetooth fait en collaboration avec M. Moreno Pour terminer la journ\u00e9e j'ai corrig\u00e9 les probl\u00e8mes de mise en forme pour la conversion avec MkDocs. Liens consult\u00e9s Bluetooth https://arduino.stackexchange.com/questions/18895/how-master-and-slave-concept-works-with-bluetooth https://fr.wikipedia.org/wiki/S%C3%A9curit%C3%A9_des_protocoles_Bluetooth https://fr.wikipedia.org/wiki/Contr%C3%B4le_de_redondance_cyclique https://fr.wikipedia.org/wiki/Protocol_Data_Unit http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gap.html#connection-parameters 30.04.2021 J'ai customis\u00e9 le th\u00e8me de la documentation g\u00e9n\u00e9r\u00e9e par MkDocs. J'ai mis \u00e0 disposition la documentation technique sur ReadTheDocs : https://ackermanngue-ag-dipl-tech-2021-voitureassistee.readthedocs.io/fr/latest/documentation_technique/ J'ai avanc\u00e9 la documentation technique afin de pouvoir me concentrer sur l'impl\u00e9mention de Flask en tant que t\u00e9l\u00e9commande pour contr\u00f4ler la voiture une fois les derniers \u00e9l\u00e9ments ajout\u00e9s. J'ai commenc\u00e9 \u00e0 travailler sur l'utilisation de Flask pour g\u00e9rer la voiture \u00e0 distance. J'ai cr\u00e9e une variable globale concernant la voiture (elle s'occupe de la connexion ainsi que du d\u00e9placement de la voiture) J'ai eu une erreur me disant que lors que je tente d'acc\u00e9der \u00e0 la route cr\u00e9ant l'objet concernant la voiture il n'\u00e9tait pas accessible alors que je l'ai d\u00e9finit en tant que variable globale. Pour palier \u00e0 ce probl\u00e8me, j'ai voulu impl\u00e9menter le design pattern Singleton car j'avais besoin de r\u00e9cup\u00e9rer la r\u00e9f\u00e9rence sur la classe afin de pouvoir ex\u00e9cuter les m\u00e9thodes associ\u00e9es. Pour ce faire, je me suis bas\u00e9 sur l'exemple pr\u00e9sent ici . La m\u00e9thode __init__ est remplac\u00e9e par la m\u00e9thode __new__ . La m\u00e9thode __init__ est appell\u00e9e lorsque l'objet doit \u00eatre initialis\u00e9 tandis que la m\u00e9thode __new__ est appel\u00e9e lors de la cr\u00e9ation de l'objet. Voici le code \u00e9crit pour le constructeur de mon objet CarController : def __new__(cls): if(cls.instance is None): cls.instance = super(CarController, cls).__new__(cls) cls.connection = get_connection_gatt(hub_mac=cls.MY_MOVEHUB_ADD) try: # The motors cls.movehub = MoveHub(cls.connection) cls.front_motor = Motor(cls.movehub, cls.movehub.PORT_A) cls.back_motor = Motor(cls.movehub, cls.movehub.PORT_B) cls.directionnal_motor = EncodedMotor(cls.movehub, cls.movehub.PORT_C) except: cls.movehub = None cls.front_motor = None cls.back_motor = None cls.directionnal_motor = None return cls.instance La raison pour laquelle on utilise cls \u00e0 la place de self c'est parce que self doit \u00eatre utilis\u00e9 pour les m\u00e9thodes d'instances tandis que cls est utilis\u00e9 pour les m\u00e9thodes de classes. Par exemple, si une classe contient une m\u00e9thode move , si nous utilisons des \u00e9l\u00e9ments propres \u00e0 la classe dans ce cas on utilisera self . Alors que pour si nous utilision une m\u00e9thode tel que __new__ ou __init__ , \u00e9tant donn\u00e9 qu'il s'agit de m\u00e9thodes de classes, on utilisera cls . #M\u00e9thode de classe __new__(cls) # M\u00e9thode d'instance move(self, motor_speed, angle_rotation) Liens consult\u00e9s Python https://www.python.org/dev/peps/pep-0008/#function-and-method-arguments https://blog.finxter.com/how-to-create-a-singleton-in-python/ https://www.geeksforgeeks.org/__new__-in-python/","title":"Logbook"},{"location":"logbook/#journal-de-bord-du-travail-de-diplome-2021","text":"","title":"Journal de bord du travail de dipl\u00f4me 2021"},{"location":"logbook/#19042021","text":"J'ai copi\u00e9 le disque dur de M. Bauduccio car le mien causait des soucis M. Moreno, M. Huber et moi avons eu un entretien avec M. Bonvin pour discuter des appr\u00e9ciations du stage J'ai mis en place mon poste (Cr\u00e9ation du repository, installation des programmes n\u00e9cessaires tel que : VS Code, Github Desktop, Suite Office, etc...) J'ai lu le chapitre 6 du magpi nomm\u00e9 \"Le guide officiel du d\u00e9butant Raspberry Pi\" conseill\u00e9 par M. Bonvin J'ai commenc\u00e9 \u00e0 m'int\u00e9resser \u00e0 l'utilisation du Remote GPIO pour \u00e9tablir une connexion entre mon Raspberry Pi 4 et celui de M. Moreno Nous avons d'abord mis nos 2 Raspberry Pi sur le m\u00eame r\u00e9seau, ensuite nous nous sommes assur\u00e9s que l'interface Remote GPIO \u00e9tait bien active des 2 c\u00f4t\u00e9s et nous avons v\u00e9rifi\u00e9 que pigpio \u00e9tait bien install\u00e9, puis pour terminer nous avons mis en place le code disponible dans ce PDF \u00e0 la page 61 sur le Raspberry Pi de M. Moreno. Avant d'ex\u00e9cuter le programme, nous avons tout deux ex\u00e9cuter la commande suivante dans un terminal sudo pigpiod De son c\u00f4t\u00e9 nous avons utilis\u00e9 un bouton pressoir et du miens une LED Le bouton est connect\u00e9 au GPIO 2, donc la pin 3 La led est connect\u00e9e au GPIO 17, donc la pin 11 Le code disponible sur la machine de M. Moreno va attendre que le bouton soit press\u00e9, une fois ceci fait, la LED connect\u00e9 en remote (li\u00e9e \u00e0 mon Raspberry Pi) se vera allum\u00e9e. J'ai commenc\u00e9 mes recherches sur l'\u00e9change d'informations par bluetooth entre 2 Raspberry Pi 4 J'ai tent\u00e9 de mettre en place le code disponible sur ce repos mais j'avais l'erreur suivante ModuleNotFoundError: No module named 'bluetooth' , pourtant j'avais d\u00e9j\u00e0 le bluetooth d'install\u00e9 ainsi que blueman. En faisant des recherches je suis tomb\u00e9 sur cette commande sudo apt-get install bluetooth libbluetooth-dev && sudo python3 -m pip install pybluez . Depuis l'installation des 2 commandes je n'ai plus d'erreurs d'import.","title":"19.04.2021"},{"location":"logbook/#liens-consultes","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#remote-gpio","text":"https://www.instructables.com/Remote-control-Raspberry-PI-GPIO-pins-over-the-int/ https://www.instructables.com/Raspberry-Pi-Remote-GPIO/ https://magpi.raspberrypi.org/articles/remote-control-gpio-raspberry-pi-gpio-zero https://magpi.raspberrypi.org/issues/60","title":"Remote GPIO"},{"location":"logbook/#echange-dinformations-par-bluetooth-entre-2-raspberry-pi-4","text":"https://technologisttips.com/raspberry-pi-bluetooth/ https://bluedot.readthedocs.io/en/latest/pairpipi.html https://gist.github.com/keithweaver/3d5dbf38074cee4250c7d9807510c7c3 https://www.stuffaboutcode.com/2017/07/python-bluetooth-rfcomm-client-server.html https://bluedot.readthedocs.io/en/latest/pairpipi.html https://stackoverflow.com/questions/23985163/python3-error-no-module-named-bluetooth-on-linux-mint#23985374","title":"\u00c9change d'informations par bluetooth entre 2 Raspberry Pi 4"},{"location":"logbook/#20042021","text":"M. Moreno et moi avons continu\u00e9 l'\u00e9change d'informations par bluetooth entre nos 2 Raspberry Pi 4 De mon c\u00f4t\u00e9, j'ai utilis\u00e9 les fonctions suivantes : lookUpNearbyBluetoothDevices , va lancer un scan bluetooth pour d\u00e9couvrir les appareils alentours. Pour chaque appareil trouv\u00e9s, ils vont \u00eatre affich\u00e9s dans la console, si l'un de ces appareils est nomm\u00e9 morenoPi42 alors son adresse mac se voit \u00eatre retourn\u00e9e pour \u00eatre utilis\u00e9e en param\u00e8tre par la fonction ci-dessous. sendMessageTo va se connecter \u00e0 un appareil \u00e0 l'aide de son adresse mac et d'un port d\u00e9sign\u00e9 (le port 1 dans notre cas) pour ensuite lui envoy\u00e9 une information et fermner la connexion. Du c\u00f4t\u00e9 de M. Moreno, il a utilis\u00e9 la m\u00e9thode receiveMessage qui va \u00e9couter sur le port sp\u00e9cifi\u00e9 (dans notre cas, il s'agit toujours du port 1), qui va ensuite accepter la connexion entrante jusqu'\u00e0 1024 bytes, puis affiche dans la console les donn\u00e9es re\u00e7ues, une fois cela fait, elle va fermer les sockets de connexion. Avec M. Moreno, nous avons modifi\u00e9 le programme pour en faire un t'chat par bluetooth. Pour lancer le programme, il faut utiliser la commande suivante en rempla\u00e7ant le XXXX par le nom d'h\u00f4te de l'appareil bluetooth : python3 bluetooth_data_transfer.py XXXX En premier temps nous avons pens\u00e9 regrouper l'ouverture des sockets dans une fonction d'initialisation afin d'avoir une trace sur les sockets pour pouvoir les fermer lorsque cela est voulu. Nous avons une erreur nous indiquant ceci _bluetooth.error: (111, 'Connection refused') , cela nous a fait comprendre que pour s'envoyer des informations, il faut que l'un \u00e9coute pendant que l'autre parle et r\u00e9ciproquement dans l'autre sens. Nous avons mis en place une boucle while qui tourne constamment. Dans cette boucle, il y a des if qui v\u00e9rifient le mode actuel. 0 veut dire que nous sommes en attente d'un message 1 veut dire que nous allons envoy\u00e9 un message 1. Affiche le nom d'h\u00f4te et l'adresse mac de l'appareil connect\u00e9 2. Espace de saisie de message \u00e0 envoyer 3. Connexion r\u00e9ussie \u00e0 l'appareil (adresse mac, port) 4. R\u00e9ception du message 5. Espace de saisie de message \u00e0 envoyer, utilisant une commande personnalis\u00e9e pour quitter le programme J'ai commenc\u00e9 mes recherches sur le Technic Hub .","title":"20.04.2021"},{"location":"logbook/#liens-consultes_1","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#echange-dinformations-par-bluetooth-entre-2-raspberry-pi-4_1","text":"https://pybluez.readthedocs.io/en/latest/api/bluetooth_socket.html","title":"\u00c9change d'informations par bluetooth entre 2 Raspberry Pi 4"},{"location":"logbook/#sockets","text":"https://docs.python.org/3/library/socket.html","title":"Sockets"},{"location":"logbook/#recuperation-de-saisie-utilisateur","text":"https://pythonprogramminglanguage.com/user-input-python/","title":"R\u00e9cup\u00e9ration de saisie utilisateur"},{"location":"logbook/#recuperation-de-parametres-en-ligne-de-commande-python","text":"https://www.pythonforbeginners.com/system/python-sys-argv","title":"R\u00e9cup\u00e9ration de param\u00e8tres en ligne de commande Python"},{"location":"logbook/#bluetooth-lego","text":"https://lego.github.io/lego-ble-wireless-protocol-docs/ https://github.com/hoharald/leguno-remote","title":"Bluetooth LEGO"},{"location":"logbook/#21042021","text":"J'ai commenc\u00e9 la journ\u00e9e par lire cet article sur le bluetooth pour tenter d'approfondir mes connaissances afin de r\u00e9gler le probl\u00e8me de connexion entre le Raspberry Pi et le Technic Hub . Apr\u00e8s avoir lu l'article, j'ai tent\u00e9 de relancer le code d'exemple disponible sur le repos Bricknil , malheureusement j'avais toujours la m\u00eame erreur. Je me suis dit que j'allais tent\u00e9 de cr\u00e9er un script python qui ne fait que se connecter pour l'instant pour pouvoir ensuite tent\u00e9 d'envoyer des ordres par bluetooth. J'ai commenc\u00e9 par essayer de lire dans cette documentation et de comprendre comment je pouvais envoyer des messages que le Technic Hub pourrait comprendre. J'ai donc en un premier temps cherch\u00e9 \u00e0 comprendre si c'\u00e9tait \u00e0 moi d'envoy\u00e9 le premier message et sur quel port ou de faire l'inverse, c'est-\u00e0-dire moi \u00e9couter un port particulier car \u00e0 chaque fois que depuis l'interface graphique ou par commande dans le terminal, quand je tente de me connecter au Technic Hub , j'ai toujours cette erreur ci : Failed to pair: org.bluez.Error.AuthenticationFailed . La premi\u00e8re chose que j'ai constat\u00e9, c'est que des fois apr\u00e8s avoir beaucoup tent\u00e9 d'utiliser le bluetooth de red\u00e9marrer le Raspberry Pi car il a de la peine \u00e0 capter les appareils alentours, tandis qu'une fois red\u00e9marr\u00e9, si l'on utilise bluetoothctl , qu'on active le scan avec scan on , on peut voir les informations suivantes : [NEW] Device 90:84:2B:50:36:43 Technic Hub [CHG] Device 90:84:2B:50:36:43 RSSI: -58 [CHG] Device 90:84:2B:50:36:43 TxPower: 0 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: 00 80 06 00 61 00 ....a. RSSI (Received Signal Strength Indicator) repr\u00e9sente la mesure du niveau de la puissance au niveau du r\u00e9cepteur. Il est mesur\u00e9 en dBm, sur une \u00e9chelle logarithmique et \u00e9tant n\u00e9gatif. Plus le nombre est n\u00e9gatif, plus le dispositif est \u00e9loign\u00e9. Par exemple, une valeur de -20 \u00e0 -30 dBm indique que le dispositif est proche, tandis qu'une valeur de -120 indique que le dispositif est proche de la limite de d\u00e9tection. TxPower repr\u00e9sente la puissance du signal. Pour un \u00e9metteur Bluetooth, 0 dBm (d\u00e9cibel-milliwatt) est le niveau de puissance standard ManufacturerData Key: 0x0397 est le code de LEGO System A/S ManufacturerData Value: 00 80 06 00 61 00 Longueur des donn\u00e9es (0x09) Le nom du type de donn\u00e9es (0xFF) L'ID du fabricant (0x0397) L'\u00e9tat du bouton (entre 0x00 et 0x01) Le type de syst\u00e8me et le num\u00e9ro de l'appareil (entre 0x00 et 0xFF) Les capacit\u00e9s de l'appareil (entre 0x01 et 0xFF) L'id du pr\u00e9c\u00e9dent r\u00e9seau (entre 0x00 et 0xFF) Le statut actuel (entre 0x00 et 0xFF) En continuant mes recherches, je me suis demand\u00e9 s'il n'\u00e9tait pas une bonne id\u00e9e de tester petit \u00e0 petit ce que propose le code de Bricknil pour ensuite l'impl\u00e9ment\u00e9 petit \u00e0 petit. Le premier \u00e9l\u00e9ment que je voulais tester \u00e9tait le bleak car j'avais vu lorsque je lan\u00e7ais le code de Bricknil qu'il y avait un message contenant le nom de ce module. Pour installer bleak , pygatt et bluepy j'ai utilis\u00e9 cette commande : sudo pip3 install pygatt && pip3 install gatt && pip3 install gattlib && pip3 install bluepy && pip3 install bleak . Une fois cela fait, j'ai donc \u00e9t\u00e9 sur le repos officiel pour ex\u00e9cuter le code pr\u00e9sent. Le premier code nous montre la m\u00e9thode discover tandis que le second nous montre une mani\u00e8re de s'appareiller. La premi\u00e8re chose que j'ai faite c'est de tester la connexion. Pour ce faire, j'ai test\u00e9 la m\u00e9thode discover disponible gr\u00e2ce \u00e0 BleakScanner . J'ai pu voir appara\u00eetre le Technic Hub dans la liste des appareils d\u00e9tect\u00e9s. Pour tenter de me \"connecter\", j'ai utilis\u00e9 l'adresse mac tel que : 90:84:2B:50:36:43 ainsi que le Characteristic UUID tel que : 00001624-1212-EFDE-1623-785FEABCD123 qui va ensuite retourner le num\u00e9ro de mod\u00e8le. La led sur le Technic Hub devient bleue lorsque je lance le programme et que la m\u00e9thode read_gatt_char est ex\u00e9cut\u00e9e. Cette m\u00e9thode retourne un array de byte, dans mon cas voici ce qu'elle me retourne \\x05\\x00\\x04\\x03\\x00.\\x00\\x00\\x10\\x00\\x00\\x00\\x10\\x00\\x00\\x00\\x00\\x00\\x00\\x00 , autrement \u00e9crit : 50430460016000160000000 .","title":"21.04.2021"},{"location":"logbook/#liens-consultes_2","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#bluetooth","text":"https://www.novelbits.io/deep-dive-ble-packets-events/ https://punchthrough.com/crash-course-in-2m-bluetooth-low-energy-phy/ https://github.com/karulis/pybluez https://www.bluetoothle.wiki/tx_power https://www.bluetoothle.wiki/rssi?s[]=rssi https://www.bluetooth.com/specifications/assigned-numbers/company-identifiers/ https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://bleak.readthedocs.io/en/latest/usage.html https://github.com/hbldh/bleak https://learn.adafruit.com/introduction-to-bluetooth-low-energy/gatt","title":"Bluetooth"},{"location":"logbook/#repos-bricknil","text":"https://github.com/virantha/bricknil","title":"Repos Bricknil"},{"location":"logbook/#date-avec-python","text":"https://www.tutorialspoint.com/How-to-print-current-date-and-time-using-Python","title":"Date avec python"},{"location":"logbook/#22042021","text":"J'ai continu\u00e9 mon travail sur le bluetooth. Histoire d'y voir un peu plus claire je me suis r\u00e9sign\u00e9 \u00e0 faire un sch\u00e9ma explicant + en d\u00e9tails quelles sont les valeurs que nous avons re\u00e7u et qu'est-ce qu'elles veulent dire \u00e0 l'aide de la documentation de Lego pour le Bluetooth . J'ai remarqu\u00e9 un potentiel probl\u00e8me. Soit c'\u00e9tait moi qui n'arrivait pas \u00e0 comprendre comment le tableau des Manufacturer Data \u00e9tait con\u00e7u ou si juste les donn\u00e9es re\u00e7us par le bluetooth lors du scan de l'appareil \u00e9taient incompl\u00e8tes. Comme on peut le voir ci-dessous, je n'ai pas pris en compte l'ID du fabricant car comme vu ici : [CHG] Device 90:84:2B:50:36:43 ManufacturerData Key: 0x0397 , il a ne semble pas avoir de champ pour lui dans le [CHG] Device 90:84:2B:50:36:43 ManufacturerData Value: . J'ai tent\u00e9 de rentrer les informations suivantes : 00 80 06 00 61 00 en prenant compte de la taille min et max de chaque cellules (voir la documentation de Lego pour le Bluetooth ) pour calculer la longueur de la trame, j'ai ensuite v\u00e9rifi\u00e9 que les donn\u00e9es puissent rentrer dans les champs et c'est \u00e0 ce moment que j'ai commenc\u00e9 \u00e0 me demander si quelque chose ne jouait pas. En effectuant des recherches, je suis tomb\u00e9 sur cet article . Il parlait d'une application smarthphone nomm\u00e9e EFR Connect . J'en avais besoin car je voulais avoir plus d'informations concernant les Manufacturer Data . J'ai lanc\u00e9 un scan depuis l'application, et en ce qui concerne voici les informations que l'application m'a retroun\u00e9e : Flags : 0x06: LE General Discoverable Mode, BR/EDR Not Supported Complete list of 128-bit service class UUIDs : 00001624-1212-EFDE-1623-785FEABCD123 Manufacturer Data : Company Code : 0x0397 Data : 0x008006004100 Slave connection interval range : 20.0ms Tx power level: 0 dBm Complete local name : Technic Hub Je me suis ensuite connect\u00e9 au Technic Hub avec l'application, j'ai vu appara\u00eetre un sous menu m'affichant 3 sections : Generic attribute : 0x1801 UUID : 0x2A05 Descriptor : champs vide Client characteristic configuration : 0x2902 Generic access : Device name : 0x1800 Appearance : 0x2A01 Peripheral preffered connection parameters : 0x2A04 Unknown Service : UUID : 00001624-1212-EFDE-1623-785FEABCD123 Descriptor : champs vide Client characteristic configuration : 0x2902 Value : 50430460016000160000000 mais lorsque depuis l'application j'active le mode notify sa valeur change \u00e0 0F 04 64 01 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 En voyant ces donn\u00e9es je me suis dit que j'avais pris les mauvaises donn\u00e9es \u00e0 mettre dans le tableau des Manufacturer Data. J'ai abandonn\u00e9 l'id\u00e9e de remplir le tableau de Manufacturer Data car ces donn\u00e9es ne correspondaient pas. En revanche, j'ai tent\u00e9 de jouer avec l'application EFR Connect car on peut lire, \u00e9crire et \u00eatre notifi\u00e9. Lorsque je me connecte au Technic Hub et que je lit les donn\u00e9es pr\u00e9sentes voici ce que je re\u00e7ois : 0F 04 64 01 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 . J'ai ensuite essayer d'envoyer la commande Hub Properties car on peut envoyer de l'hexad\u00e9cimal au hub, j'ai donc tent\u00e9 avec les valeurs du tableau ici pr\u00e9sent . Ensuite, avec le mode \u00e9criture lorsque j'ai relus le contenu avec chang\u00e9 et \u00e9tait devenu : 05 00 05 00 05 36 00 01 00 00 00 01 00 00 00 00 00 00 00 00 . En me balandant sur internet je suis retomb\u00e9 sur ce lien qui disait que le Technich Hub peut uniquement \u00eatre programm\u00e9 avec le firmware de PyBricks. J'ai donc essay\u00e9 de t\u00e9l\u00e9charger le repos git et d'installer le firmware \"manuellement\" afin de pouvoir \u00e9crire mes propres script python pour contr\u00f4ler la voiture. J'ai suivi le tutoriel de mise en place pour un environnement de d\u00e9veloppement mais je n'ai r\u00e9ussi \u00e0 le mettre en place. Je suis ensuite tomb\u00e9 sur cette issue git qui met \u00e0 disposition des fichier de firmware pour les hub Spike et Mindstorm . J'ai ensuite retent\u00e9 de comprendre comment lire la documentation de Lego .","title":"22.04.2021"},{"location":"logbook/#liens-consultes_3","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#bluetooth_1","text":"https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://stackoverflow.com/questions/52352378/manufacturer-specific-data-on-ble https://docs.silabs.com/bluetooth/2.13/code-examples/stack-features/adv-and-scanning/adv-manufacturer-specific-data https://brickarchitect.com/powered-up/#footnote1 https://github.com/pybricks/pybricks-micropython https://github.com/pybricks/support/issues/167 https://github.com/pybricks/pybricksdev","title":"Bluetooth"},{"location":"logbook/#23042021","text":"J'ai commenc\u00e9 la journ\u00e9e par lire cette documentation pour mieux comprendre ce qu'est GATT et comment il est structur\u00e9, pour pouvoir l'utiliser ensuite. Les attributs GATT sont des \u00e9l\u00e9ments d'information adressables qui peuvent contenir des donn\u00e9es utilisateur pertinentes (ou m\u00e9tadonn\u00e9es) sur la structure et le regroupement des diff\u00e9rents attributs contenus dans le serveur. Gatt est structur\u00e9 de la mani\u00e8re suivante : Roles Client Server UUID Attributes Handle : 0x0000 = d\u00e9note un handle invalde, le montant d'handle dipsonible sur chaque serveur GATT est 0xFFFF (soit 16 bits, 65535) Type : d\u00e9termine le type de donn\u00e9e des valeurs de l'attribut, il s'agit d'un UUID Permissions Access permissions : similaire au droit li\u00e9 aux fichiers (None, Readable, Writable, Readable & Writable) Encryption : Security mode 1, level 1 Attribut accessible en texte, connexion non encrypt\u00e9e Security mode 1, level 2 La connexion doit \u00eatre encrypt\u00e9e pour avoir acc\u00e8s \u00e0 l'attribut, mais les cl\u00e9s d'encryptions non pas besoin d'\u00eatre authentifi\u00e9es Security mode 1, level 3 La connexion doit \u00eatre encrypt\u00e9e avec des cl\u00e9s authentifi\u00e9es pour avois acc\u00e8s \u00e0 l'attribut. Autorization : d\u00e9termine si une permission utilisateur est n\u00e9cessaire Value : Contient les donn\u00e9es de l'attribut, il n'y a pas de restrictions pour le type de donn\u00e9es qu'il contient mais jusqu'\u00e0 une limite de 512 bytes Attribute and data hierarchy GATT Server : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown service) Characteristic : Unknown Charateristic Les attributs sont group\u00e9s en services , chaque services peut contenir 0 ou + characteristics . Ces derni\u00e8res peuvent avoir de 0 \u00e0 + descriptors Advanced attribute concepts Features Security GATT service J'ai install\u00e9 gatt \u00e0 l'aide de la commande sudo pip3 install gatt . Ensuite j'ai scann\u00e9 les alentours avec la commande sudo gattctl --discover . Une fois que j'ai vu appara\u00eetre le Technic Hub je m'y suis connect\u00e9 \u00e0 l'aide de sudo gattctl --connect 90:84:2B:50:36:43 . On peut voir que les donn\u00e9es re\u00e7ues sont bien celles pr\u00e9sentes dans l'application EFR Connect : Connecting... [90:84:2b:50:36:43] Discovered, alias = Technic Hub [90:84:2b:50:36:43] Connected [90:84:2b:50:36:43] Discovered, alias = Technic Hub [90:84:2b:50:36:43] Resolved services [90:84:2b:50:36:43] Service [00001623-1212-efde-1623-785feabcd123] [90:84:2b:50:36:43] Characteristic [00001624-1212-efde-1623-785feabcd123] [90:84:2b:50:36:43] Service [00001801-0000-1000-8000-00805f9b34fb] [90:84:2b:50:36:43] Characteristic [00002a05-0000-1000-8000-00805f9b34fb] M. Bonvin m'a montr\u00e9 comment utiliser QCad , c'est un outil de dessin technique assit\u00e9. Je me suis ensuite remis sur la documentation pour comprendre comment cela marchait. J'ai ex\u00e9cuter le second code pr\u00e9sent sur le repos mais cette erreur m'est apparue : ERROR:dbus.connection:Exception in handler for D-Bus signal: Traceback (most recent call last): File \"/usr/local/lib/python3.7/dist-packages/dbus/connection.py\", line 232, in maybe_handle_message self._handler(*args, **kwargs) File \"/home/pi/.local/lib/python3.7/site-packages/gatt/gatt_linux.py\", line 398, in properties_changed self.services_resolved() File \"gatt_connection.py\", line 10, in services_resolved s for s in self.services StopIteration J'ai \u00e9t\u00e9 voir sur internet ce que l'erreur ERROR:dbus.connection:Exception in handler for D-Bus signal voulait signifier. Je n'ai pas r\u00e9ussis \u00e0 trouver d'informations pertinentes, donc je me suis remis sur le script python utilisant GATT. J'ai tent\u00e9 de modifier le second code afin d'\u00eatre s\u00fbr qu'il fonctionnait. Il semble donc que l'erreur vienne du second script. J'ai cherch\u00e9 ce quel \u00e9l\u00e9ment pose probl\u00e8me mais je peine encore \u00e0 trouver le probl\u00e8me.","title":"23.04.2021"},{"location":"logbook/#liens-consultes_4","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#bluetooth_2","text":"http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gatt.html https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch04.html https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch02.html#Protocol_Stack https://doc.qt.io/qt-5/qtbluetooth-le-overview.html https://github.com/getsenic/gatt-python","title":"Bluetooth"},{"location":"logbook/#26042021","text":"","title":"26.04.2021"},{"location":"logbook/#liens-consultes_5","text":"Pour commencer la semaine, je me suis dit que regarder des vid\u00e9os explicative sur le fonctionnement de GATT et du bluetooth en g\u00e9n\u00e9ral, car ayant pass\u00e9 la semaine pass\u00e9e sur de la documentation explicative sur GATT mais qui ne m'avait pas aid\u00e9 \u00e0 r\u00e9soudre les soucis que j'avais. Comme pour le 23.04.2021, je vais tenter de refaire une explication d\u00e9taill\u00e9e du fonctionnement de GAP et GATT car \u00e7a me permettera de l'inclure plus ais\u00e9ment dans la documentation que je n'ai toujours pas commenc\u00e9e \u00e0 l'heure actuelle, mais je me suis dit qu'aujourd'hui devait \u00eatre le dernier d\u00e9lai pour conclure cette histoire de bluetooth car il faut que je me concentre sur la documentation technique sachant qu'elle sera \u00e9valu\u00e9e le 30.04.2021. GAP , Generic Access Profile , contr\u00f4le les connexions ainsi que l'avertissement d\u00e9terminant comment les 2 appareils vont pouvoir ou pas int\u00e9ragir. GATT , Generic Attribute Profile ,d\u00e9finit comment les 2 appareils vont \u00e9changer des donn\u00e9es compos\u00e9es de Services et de Characteristics . Ce protocole int\u00e9rvient uniquement une fois le GAP pass\u00e9. J'ai repris la structure que j'avais faite pour montrer la structure du Technic Hub au niveau GATT : Profile : Technic Hub Service : Generic Attribute Characteristic : Service Change Service : Generic Access Characteristic : Device Name Characteristic : Appearance Characteristic : Peripheral Preferred Connection Parameters Service : LegoTechnicHub (renomm\u00e9e car de base l'application affichait Unknown service) Characteristic : Unknown Charateristic Comme on peut le voir, Profile contient une collection de services. Ces derniers divisent les donn\u00e9es en entit\u00e9s logiques qui contiennent des blocs de donn\u00e9es sp\u00e9cifiques appel\u00e9s caract\u00e9ristiques. Ce sont ces caract\u00e9ristiques qui contiennent les donn\u00e9es importantes. Depuis l'application mobile EFR Connect , j'ai tent\u00e9 dans la characteristic concernant le Technic Hub d'\u00e9crire des commandes de la mani\u00e8re suivante : Dans la documentation lego les commandes sont dans un chapitre Output Command 0x81 . Dans ce chapitre, les commandes pr\u00e9sentent sont \u00e9crites comme suit StartPower (Power1, Power2): Output Command 0x81 - Sub Command 0x02 . \u00c9tant donn\u00e9 qu'il s'agit de sub command , je ne sais pas si \u00e9crire en hexa une suite de bytes en hexa permet d'ex\u00e9cuter une commande. En tout cas, depuis que j'ai tent\u00e9 d'\u00e9crire une commande, lorsque j'ai activ\u00e9 le mode notify la valeur retourn\u00e9e est la suivante 0F 00 04 61 01 39 00 01 00 00 00 01 00 00 00 . Je sais que je change de cap souvent, mais \u00e9tant un peu perdu je tente d'explorer chaques id\u00e9es qui me vient en t\u00eate. Celle que je viens d'avoir concerne l'utilisation du code pr\u00e9sent sur le repos de pyboost , car m\u00eame s'il concerne le LEGO Boost Move Hub je me suis dit qu'il y a moyen que puisse l'utiliser. De plus sur la documentation de Lego Wireless Protocol il parlait de SDK, je me suis dit qu'il fallait que je trouve un bon SDK et je suis alors tomb\u00e9 en premier temps sur celle de pyb00st . Par cons\u00e9quent, j'ai clon\u00e9 le repos sur le Raspberry Pi afin d'ex\u00e9cuter les codes d'exemples. J'ai commenc\u00e9 par utiliser la m\u00e9thode set_led_color(color) pour voir si la connexion et les m\u00e9thodes int\u00e9ragissaient avec le Technic Hub . R\u00e9sultat, \u00e7a fonctionne. Maintenant je vais m'int\u00e9resser aux m\u00e9thodes touchant aux moteurs. je n'ai pas r\u00e9ussi \u00e0 impl\u00e9menter pyb00st , cependant je me suis dit que d'utiliser le code de pylgbst pourrait fonctionner car j'ai \u00e9t\u00e9 lire la documentation Lego , et vu qu'elle parle de commandes \u00e0 envoy\u00e9, j'ai \u00e9t\u00e9 voir s'il en proposait. Apr\u00e8s quelque recherche, j'ai vu que oui. M\u00eame si rien n'\u00e9tait \u00e9cris \u00e0 propos du Technic Hub , je me suis lanc\u00e9 en me disant que \u00e7a doit \u00eatre exactement le m\u00eame m\u00e9canisme. J'ai commenc\u00e9 par utiliser la m\u00e9thode get_connection_auto() , cette fonction va choisir parmi la liste suivante : bluepy bluegiga gatt bleak gattool gattlib \u00c0 noter qu'on peut choisir par nous m\u00eame quel type de connexion nous voulons \u00e9tablir en reprennant get_connection_auto() mais en repla\u00e7ant le auto par l'un des moyens disponible ci-dessus. M'\u00e9tant document\u00e9 ces dernier jours sur GATT et ayant utilis\u00e9 un code fonctionnel, je suis partit du postulat que \u00e7a devrait fonctionn\u00e9 sans soucis. J'ai donc commenc\u00e9 par utiliser la m\u00e9thode get_connection_gatt() en lui sp\u00e9cifiant l'adresse mac de l'appareil comme suit : get_connection_gatt(hub_mac=\"90:84:2B:50:36:43\") . La m\u00e9thode affiche ceci dans la console : Have not dedicated class for peripheral type 0x2f on port 0x0 Have not dedicated class for peripheral type 0x2f on port 0x1 Have not dedicated class for peripheral type 0x2e on port 0x2 Have not dedicated class for peripheral type 0x3c on port 0x3d Have not dedicated class for peripheral type 0x3c on port 0x60 Have not dedicated class for peripheral type 0x39 on port 0x61 Have not dedicated class for peripheral type 0x3a on port 0x62 Have not dedicated class for peripheral type 0x3b on port 0x63 Have not dedicated class for peripheral type 0x36 on port 0x64 Got only these devices: (Peripheral on port 0x0, Peripheral on port 0x1, None, LEDRGB on port 0x32, None, Current on port 0x3b, Voltage on port 0x3c) Une fois ceci affich\u00e9, j'ai cr\u00fb comprendre que la connexion \u00e9tait bien \u00e9tablie et que des commandes pouvait \u00eatre envoy\u00e9es. J'ai regard\u00e9 dans les fichiers peripherals et hub fournis par pylgbst comment \u00e9tait structur\u00e9 la classe moteur et quels fonctions \u00e9taient disponibles. Apr\u00e8s avoir compris, j'ai \u00e9crit ce bout de code : from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor from pylgbst import * MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) motor_a = Motor(movehub, movehub.PORT_A) motor_c = Motor(movehub, movehub.PORT_C) motor_a.start_power(-1) motor_c.start_power(1) conn.disconnect() finally: conn.disconnect() Ce bout de code fonctionne parfaitement. Entre temps j'ai \u00e9cris celui ci qui fonctionne parfaitement lui aussi : #!/usr/bin/env python3 from pylgbst.hub import MoveHub from pylgbst.peripherals import Motor from pylgbst import * from time import sleep MY_MOVEHUB_ADD = \"90:84:2B:50:36:43\" MY_BTCTRLR_HCI = \"hci0\" def play_scenario(movehub): motor_a = Motor(movehub, movehub.PORT_A) motor_b = Motor(movehub, movehub.PORT_B) motor_c = EncodedMotor(movehub, movehub.PORT_C) print(\"Forward:\") forward(motor_a, motor_b, motor_c) sleep(1) print(\"Downward:\") downward(motor_a, motor_b, motor_c) sleep(1) print(\"Left:\") go_left(motor_a, motor_b, motor_c) sleep(1) print(\"Right:\") go_right(motor_a, motor_b, motor_c) sleep(1) def forward(motor_1, motor_2, motor_3): motor_1.start_power(-1) motor_2.start_power(-1) motor_3.start_power(0) print(\"done!\") def downward(motor_1, motor_2, motor_3): motor_1.start_power(1) motor_2.start_power(1) motor_3.start_power(0) print(\"done!\") def go_left(motor_1, motor_2, motor_3): motor_1.start_power(0) motor_2.start_power(0) motor_3.start_power(-1) print(\"done!\") def go_right(motor_1, motor_2, motor_3): motor_1.start_power(0) motor_2.start_power(0) motor_3.start_power(1) print(\"done!\") conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) try: movehub = MoveHub(conn) play_scenario(movehub) conn.disconnect() finally: conn.disconnect() Cependant de temps en temps quand je relance le programme. Cette erreur appara\u00eet : Traceback (most recent call last): File \"pylgbst_bluetooth.py\", line 53, in <module> conn = get_connection_gatt(hub_mac=MY_MOVEHUB_ADD) File \"/usr/local/lib/python3.7/dist-packages/pylgbst/__init__.py\", line 25, in get_connection_gatt return GattConnection(controller).connect(hub_mac, hub_name) File \"/usr/local/lib/python3.7/dist-packages/pylgbst/comms/cgatt.py\", line 100, in connect for dev in devices: RuntimeError: dictionary changed size during iteration Pour la r\u00e9soudre, en g\u00e9n\u00e9ral, j'\u00e9teins le bluetooth puis je le rallume et cela semble r\u00e9soudre le probl\u00e8me de temps en temps. De temps \u00e0 autre cette technique ne fonctionne pas et je dois red\u00e9marrer le Raspberry Pi afin de r\u00e9gler le probl\u00e8me. J'ai essay\u00e9 pendant un long moment \u00e0 mettre en place un syst\u00e8me qui permetterai de reset l'angle du moteur g\u00e9rant la direction. Le probl\u00e8me que j'ai est que je n'ai pas r\u00e9ussi \u00e0 trouver les valeurs minimals et maximales pour les angles, car lorsque l'on dit au moteur d'utiliser la fonction angled(degrees=-150) suivi de angled(degrees=75) , ce qui devrait mettre le moteur tout \u00e0 droite puis au centre mais le probl\u00e8me est qu'apr\u00e8s la premi\u00e8re instruction, l'ex\u00e9cution s'arr\u00eate. Est-ce que la premi\u00e8re valeur fait crash le programme ? Ayant pratiquement termin\u00e9 avec le bluetooth, je me suis dit que je devais commencer la documentation technique car pour l'heure rien n'avait \u00e9t\u00e9 fait \u00e0 ce sujet.","title":"Liens consult\u00e9s"},{"location":"logbook/#bluetooth-youtube","text":"https://www.youtube.com/watch?v=u4HY3OIk2-c https://www.youtube.com/watch?v=MzM3-YWftxE https://www.youtube.com/watch?v=E8_5UZWDgMo https://www.youtube.com/watch?v=eHqtiCMe4NA","title":"Bluetooth Youtube"},{"location":"logbook/#bluetooth_3","text":"http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gatt.html#gatt-characteristics-and-attributes https://www.oreilly.com/library/view/getting-started-with/9781491900550/ch04.html#gatt_attr_table https://devzone.nordicsemi.com/f/nordic-q-a/6700/adding-characteristic-user-description-0x2901-0x2902 https://github.com/getsenic/gatt-python https://bleak.readthedocs.io/en/latest/usage.html https://lego.github.io/lego-ble-wireless-protocol-docs/index.html https://github.com/peplin/pygatt https://github.com/JorgePe/pyb00st https://github.com/undera/pylgbst","title":"Bluetooth"},{"location":"logbook/#27042021","text":"J'ai d\u00e9but\u00e9 la journ\u00e9e en continuant le documentation technique. Durant l'apr\u00e8s-midi, avec M. Ray Yvelin, M. Bonvin et moi m\u00eame, nous sommes aller apporter du mat\u00e9riel en C305 \u00e0 Ternier et nous avons pris dans cette salle : 1 Oscilloscope 1 Alimentation stabilis\u00e9e Les c\u00e2bles associ\u00e9s au \u00e9l\u00e9ments ci-dessus Des tournevis 1 Fer \u00e0 souder avec de la soudure 1 Multim\u00e8tre 1 \u00c9taux Apr\u00e8s cela j'ai continu\u00e9 \u00e0 travailler sur la documentation technique.","title":"27.04.2021"},{"location":"logbook/#liens-consultes_6","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#donnees-relatives-au-capteurs","text":"https://pijaeducation.com/arduino/sensor/ir-sensor-and-arduino/ https://fr.wikipedia.org/wiki/Baud_(mesure) https://fr.wikipedia.org/wiki/UART http://bucket.download.slamtec.com/20b2e974dd7c381e46c78db374772e31ea74370d/LD208_SLAMTEC_rplidar_datasheet_A2M8_v2.6_en.pdf https://en.wikipedia.org/wiki/Pulse-width_modulation https://github.com/Slamtec/rplidar_sdk/releases/tag/release%2Fv1.12.0","title":"Donn\u00e9es relatives au capteurs"},{"location":"logbook/#28042021","text":"J'ai continu\u00e9 la documentation technique. Apr\u00e8s l'entretien avec M. Bonvin, j'ai mis \u00e0 disposition le code \u00e9crit sur le Raspberry Pi, puis je me suis remis \u00e0 travailler sur la documentation technique. Pour expliquer plus en d\u00e9tails les composants qui composeront le voiture, j'ai r\u00e9alis\u00e9 ce croquis : J'ai tent\u00e9 d'importer l'\u00e9tat actuel de ma documentation technique sur ReadTheDoc, mais la version en ligne qui cr\u00e9ait une documentation \u00e0 partir d'un repository Github ne fonctionnait pas vraiment. J'ai alors install\u00e9 MkDocs pour g\u00e9n\u00e9rer la documentation \u00e0 partir du fichier Markdown.","title":"28.04.2021"},{"location":"logbook/#liens-consultes_7","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#flask","text":"https://flask.palletsprojects.com/en/1.1.x/quickstart/","title":"Flask"},{"location":"logbook/#mkdocs","text":"https://www.mkdocs.org/#installation","title":"MkDocs"},{"location":"logbook/#29042021","text":"J'ai commenc\u00e9 par d\u00e9finir plus clairement ce qu'\u00e9tait le bluetooth dans la documentation technique. J'ai recompil\u00e9 la documentation technique avec MkDocs pour avoir un aper\u00e7u de la mise en forme. J'ai eu des soucis de mise en page en ce qui concerne les listes \u00e0 points ou num\u00e9rot\u00e9es tandis qu'affiche en Markdown fonctionnent tr\u00e8s bien. Pour ne pas perdre plus de temps dessus j'ai comment\u00e9 tous le code \u00e9crit. Apr\u00e8s avoir tous comment\u00e9, je me suis remis sur la documentation afin d'expliquer le T'chat bluetooth fait en collaboration avec M. Moreno Pour terminer la journ\u00e9e j'ai corrig\u00e9 les probl\u00e8mes de mise en forme pour la conversion avec MkDocs.","title":"29.04.2021"},{"location":"logbook/#liens-consultes_8","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#bluetooth_4","text":"https://arduino.stackexchange.com/questions/18895/how-master-and-slave-concept-works-with-bluetooth https://fr.wikipedia.org/wiki/S%C3%A9curit%C3%A9_des_protocoles_Bluetooth https://fr.wikipedia.org/wiki/Contr%C3%B4le_de_redondance_cyclique https://fr.wikipedia.org/wiki/Protocol_Data_Unit http://software-dl.ti.com/lprf/sdg-latest/html/ble-stack-3.x/gap.html#connection-parameters","title":"Bluetooth"},{"location":"logbook/#30042021","text":"J'ai customis\u00e9 le th\u00e8me de la documentation g\u00e9n\u00e9r\u00e9e par MkDocs. J'ai mis \u00e0 disposition la documentation technique sur ReadTheDocs : https://ackermanngue-ag-dipl-tech-2021-voitureassistee.readthedocs.io/fr/latest/documentation_technique/ J'ai avanc\u00e9 la documentation technique afin de pouvoir me concentrer sur l'impl\u00e9mention de Flask en tant que t\u00e9l\u00e9commande pour contr\u00f4ler la voiture une fois les derniers \u00e9l\u00e9ments ajout\u00e9s. J'ai commenc\u00e9 \u00e0 travailler sur l'utilisation de Flask pour g\u00e9rer la voiture \u00e0 distance. J'ai cr\u00e9e une variable globale concernant la voiture (elle s'occupe de la connexion ainsi que du d\u00e9placement de la voiture) J'ai eu une erreur me disant que lors que je tente d'acc\u00e9der \u00e0 la route cr\u00e9ant l'objet concernant la voiture il n'\u00e9tait pas accessible alors que je l'ai d\u00e9finit en tant que variable globale. Pour palier \u00e0 ce probl\u00e8me, j'ai voulu impl\u00e9menter le design pattern Singleton car j'avais besoin de r\u00e9cup\u00e9rer la r\u00e9f\u00e9rence sur la classe afin de pouvoir ex\u00e9cuter les m\u00e9thodes associ\u00e9es. Pour ce faire, je me suis bas\u00e9 sur l'exemple pr\u00e9sent ici . La m\u00e9thode __init__ est remplac\u00e9e par la m\u00e9thode __new__ . La m\u00e9thode __init__ est appell\u00e9e lorsque l'objet doit \u00eatre initialis\u00e9 tandis que la m\u00e9thode __new__ est appel\u00e9e lors de la cr\u00e9ation de l'objet. Voici le code \u00e9crit pour le constructeur de mon objet CarController : def __new__(cls): if(cls.instance is None): cls.instance = super(CarController, cls).__new__(cls) cls.connection = get_connection_gatt(hub_mac=cls.MY_MOVEHUB_ADD) try: # The motors cls.movehub = MoveHub(cls.connection) cls.front_motor = Motor(cls.movehub, cls.movehub.PORT_A) cls.back_motor = Motor(cls.movehub, cls.movehub.PORT_B) cls.directionnal_motor = EncodedMotor(cls.movehub, cls.movehub.PORT_C) except: cls.movehub = None cls.front_motor = None cls.back_motor = None cls.directionnal_motor = None return cls.instance La raison pour laquelle on utilise cls \u00e0 la place de self c'est parce que self doit \u00eatre utilis\u00e9 pour les m\u00e9thodes d'instances tandis que cls est utilis\u00e9 pour les m\u00e9thodes de classes. Par exemple, si une classe contient une m\u00e9thode move , si nous utilisons des \u00e9l\u00e9ments propres \u00e0 la classe dans ce cas on utilisera self . Alors que pour si nous utilision une m\u00e9thode tel que __new__ ou __init__ , \u00e9tant donn\u00e9 qu'il s'agit de m\u00e9thodes de classes, on utilisera cls . #M\u00e9thode de classe __new__(cls) # M\u00e9thode d'instance move(self, motor_speed, angle_rotation)","title":"30.04.2021"},{"location":"logbook/#liens-consultes_9","text":"","title":"Liens consult\u00e9s"},{"location":"logbook/#python","text":"https://www.python.org/dev/peps/pep-0008/#function-and-method-arguments https://blog.finxter.com/how-to-create-a-singleton-in-python/ https://www.geeksforgeeks.org/__new__-in-python/","title":"Python"}]}